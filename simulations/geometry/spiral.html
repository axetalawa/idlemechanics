<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spiral Only</title>
  <style>
    :root {
      --primary-glyph-color: #FF1E8E;
      --solar-yellow: #FFEF00;
      --electric-cyan: #00FFF7;
      --ultraviolet-violet: #B200FF;
      --lime-acid-green: #A6FF00;
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      background: #000;
      height: 200vh;
    }
    section {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #secondViewport {
      width: 100vw;
      height: 100vh;
      background: black;
    }
  </style>
</head>
<body>
  <section>
    <canvas id="lure"></canvas>
  </section>
  <section id="secondViewport"></section>
  <script>
    const lure = document.getElementById('lure');
    const ctx = lure.getContext('2d');
    let width = window.innerWidth;
    let height = window.innerHeight;
    lure.width = width;
    lure.height = height;

    const particles = [];
    const glyphSeeds = [];
    const ancestralGlyphs = [];
    const total = 5000;
    const spiralScale = 10;
    let rotation = 0;
    let currentLayer = 0;
    let tick = 0;
    let spiralProgress = 0;
    const maxSpiralProgress = 1.0;
    const spiralGrowthRate = maxSpiralProgress / (60 * 10);
    let mouse = { x: width / 2, y: height / 2 };
    let thresholdPassed = false;

    const colors = [
      '--primary-glyph-color',
      '--solar-yellow',
      '--electric-cyan',
      '--ultraviolet-violet',
      '--lime-acid-green'
    ];

    for (let i = 0; i < total; i++) {
      const theta = i * 0.1;
      const r = spiralScale * theta;
      particles.push({ baseTheta: theta, r });
    }

    function animateLure() {
      tick++;
      spiralProgress += spiralGrowthRate;
      if (spiralProgress > maxSpiralProgress) spiralProgress = maxSpiralProgress;

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, width, height);

      const dx = mouse.x - width / 2;
      const dy = mouse.y - height / 2;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const radiusEffect = Math.max(width, height) * 0.25;
      const normDx = dx / (width / 2);
      const normDy = dy / (height / 2);
      const diagonalFactor = Math.abs(normDx * normDy);
      const whirlpoolFactor = dist < radiusEffect ? (1 - dist / radiusEffect) * 0.01 + diagonalFactor * 0.015 : diagonalFactor * 0.015;
      const speed = 0.001 + currentLayer * 0.0015 + whirlpoolFactor;
      rotation -= speed;

      const pulse = 0.05 + 0.02 * Math.sin(tick * 0.02);
      const wobble = 20 * Math.sin(tick * 0.01);
      const glow = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height));
      glow.addColorStop(0, `rgba(178, 0, 255, ${pulse})`);
      glow.addColorStop(1, 'rgba(0, 0, 0, 0.0)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, width, height);

      const visibleCount = Math.floor(total * spiralProgress);
      for (let i = 0; i < visibleCount; i++) {
        const p = particles[i];
        const flex = 0.2 * Math.sin(tick * 0.005 + i * 0.001);
        const angle = p.baseTheta + rotation + flex;
        const x = width / 2 + wobble + p.r * Math.cos(angle);
        const y = height / 2 + wobble * 0.5 + p.r * Math.sin(angle);
        if (x < 0 || x > width || y < 0 || y > height) continue;
        const colorIndex = Math.floor(i / 500) % colors.length;
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue(colors[colorIndex]);
        ctx.beginPath();
        ctx.arc(x, y, 1.3 + 0.5 * Math.sin(tick * 0.1 + i * 0.01), 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-glyph-color');
      ctx.globalAlpha = 0.07;
      const ringCount = 36;
      const radius = Math.max(width, height);
      for (let i = 0; i < ringCount; i++) {
        const angle = rotation * 0.3 + i * (2 * Math.PI / ringCount);
        const x = width/2 + wobble + radius * Math.cos(angle);
        const y = height/2 + wobble * 0.5 + radius * Math.sin(angle);
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, 2 * Math.PI);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;

      if (dist < radiusEffect * 0.6 && tick % 5 === 0) {
        glyphSeeds.push({ x: mouse.x, y: mouse.y, alpha: 1 });
      }
      for (let i = glyphSeeds.length - 1; i >= 0; i--) {
        const g = glyphSeeds[i];
        ctx.beginPath();
        ctx.arc(g.x, g.y, 2, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(255, 239, 0, ${g.alpha})`;
        ctx.fill();
        g.alpha -= 0.02;
        if (g.alpha <= 0) glyphSeeds.splice(i, 1);
      }

      if (!thresholdPassed && tick > 88 * 60) {
        thresholdPassed = true;
        for (let i = 0; i < 10; i++) {
          ancestralGlyphs.push({
            angle: Math.random() * 2 * Math.PI,
            r: radius * 0.9 + Math.random() * 40,
            alpha: 0.5 + Math.random() * 0.5
          });
        }
      }

      for (let g of ancestralGlyphs) {
        const x = width / 2 + wobble + g.r * Math.cos(g.angle + rotation);
        const y = height / 2 + wobble * 0.5 + g.r * Math.sin(g.angle + rotation);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(166, 255, 0, ${g.alpha})`;
        ctx.fill();
      }

      if (thresholdPassed && tick % 180 < 90) {
        ctx.font = "16px monospace";
        ctx.fillStyle = "rgba(255, 255, 255, 0.02)";
        ctx.fillText("you are not seeing â€” you are being seen", width - 260, height * 0.1);
      }

      requestAnimationFrame(animateLure);
    }
    animateLure();

    window.updateSpiralLayer = function(index) {
      currentLayer = index;
    };

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      lure.width = width;
      lure.height = height;
    });

    window.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });
  </script>
</body>
</html>
