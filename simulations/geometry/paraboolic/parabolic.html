<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Título Atualizado -->
    <title>Parabolic Spiral [Idle Mechanics]</title>
    
    <!-- Fonte e Tema CSS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="idle-mechanics-theme.css">

    <style>
        /* Estilos essenciais mantidos */
        .spiral-window {
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .spiral-svg {
            width: 100vw;
            height: 100vh;
            animation: spin 30s linear infinite;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .spiral-path {
            stroke: url(#gradient);
            fill: none;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Wrapper para o botão */
        .button-wrapper {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
    </style>
</head>
<body> 

    <!-- Definição SVG para o gradiente -->
    <svg width="0" height="0" style="position:absolute;">
        <defs>
            <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <!-- 
                  CORRIGIDO: Cores embutidas (hard-coded) para garantir que o SVG as renderize, 
                  em vez de depender de variáveis CSS externas.
                -->
                 <stop offset="0%" style="stop-color: #fff204; stop-opacity:1" /> <!-- Amarelo -->
                 <stop offset="100%" style="stop-color: #ff0090; stop-opacity:1" /> <!-- Rosa -->
            </linearGradient>
        </defs>
    </svg>

    <main>
        <!-- Janela da Espiral Parabólica (Fermat) -->
        <div class="spiral-window">
            <svg class="spiral-svg" viewBox="-350 -350 700 700">
                <path class="spiral-path" id="parabolic-path"></path>
            </svg>
        </div>
        <!-- Botão Atualizado com Classes de Tema -->
        <div class="button-wrapper">
            <button id="mode-toggle" class="im-button"></button>
        </div>
    </main>

    <script>
        // --- JAVASCRIPT INALTERADO ---
        document.addEventListener('DOMContentLoaded', () => {
            const parabolicSpiral = {
                id: 'parabolic-path',
                generator: (progress) => { 
                    let path = 'M 0,0';
                    const initialA = 0.1;
                    const finalA = 400;
                    const currentA = initialA + (finalA - initialA) * progress;
                    const initialIterations = 1;
                    const finalIterations = 10000;
                    const currentIterations = initialIterations + (finalIterations - initialIterations) * progress;
                    
                    // First arm
                    for (let i = 0; i < currentIterations; i++) {
                        const angle = 0.1 * i;
                        const r = currentA * Math.sqrt(angle);
                        path += ` L ${r * Math.cos(angle)},${r * Math.sin(angle)}`;
                    }
                    // Second arm for symmetry
                    path += ' M 0,0';
                    for (let i = 0; i < currentIterations; i++) {
                        const angle = 0.1 * i;
                        const r = -currentA * Math.sqrt(angle);
                        path += ` L ${r * Math.cos(angle)},${r * Math.sin(angle)}`;
                    }
                    return path;
                }
            };

            function easeInOutCubic(t) { 
                 return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            function triggerSpiralAnimation(config) { 
                const pathEl = document.getElementById(config.id);
                if (!pathEl) return;
                const svgElement = pathEl.closest('.spiral-svg');
                if (!svgElement) return;
                const modeToggleButton = document.getElementById('mode-toggle');

                let startTime = null;
                const duration = 15000;
                const initialViewBoxSize = 700;
                const finalViewBoxSize = 20000;
                const initialStrokeWidth = 1;
                const finalStrokeWidth = 8;

                let keepSpinning = false;
                let direction = 1; // 1 for growing, -1 for shrinking
                let pausedAtMax = false;
                let pauseTimeoutId = null;

                modeToggleButton.addEventListener('click', () => {
                    keepSpinning = !keepSpinning;
                    modeToggleButton.classList.toggle('active', keepSpinning);

                    clearTimeout(pauseTimeoutId);
                    pauseTimeoutId = null;

                    if (!keepSpinning && pausedAtMax) {
                        pausedAtMax = false;
                        direction = -1;
                        startTime = null;
                    }
                });


                function animate(currentTime) {
                    if (pausedAtMax && keepSpinning) {
                        requestAnimationFrame(animate);
                        return; // Stay at max size, CSS handles spinning
                    }

                    if (startTime === null) startTime = currentTime;
                    
                    let elapsedTime = currentTime - startTime;
                    let rawProgress = Math.min(elapsedTime / duration, 1);

                    const easedProgress = (direction === 1) 
                        ? easeInOutCubic(rawProgress) 
                        : easeInOutCubic(1 - rawProgress);

                    const newPathData = config.generator(easedProgress);
                    pathEl.setAttribute('d', newPathData);

                    const currentViewBoxSize = initialViewBoxSize + (finalViewBoxSize - initialViewBoxSize) * easedProgress;
                    const currentMin = -currentViewBoxSize / 2;
                    svgElement.setAttribute('viewBox', `${currentMin} ${currentMin} ${currentViewBoxSize} ${currentViewBoxSize}`);

                    const currentStrokeWidth = initialStrokeWidth + (finalStrokeWidth - initialStrokeWidth) * easedProgress;
                    pathEl.style.strokeWidth = `${currentStrokeWidth}px`;

                    if (rawProgress >= 1) {
                        if (direction === 1) { // Finished growing
                            if (keepSpinning) {
                                pausedAtMax = true;
                            } else {
                                if (!pauseTimeoutId) {
                                    pauseTimeoutId = setTimeout(() => {
                                        direction = -1;
                                        startTime = null;
                                        pauseTimeoutId = null;
                                    }, 5000); // 5-second pause
                                }
                            }
                        } else { // Finished shrinking
                            direction = 1;
                            startTime = null;
                            pausedAtMax = false;
                        }
                    }
                    requestAnimationFrame(animate);
                }
                requestAnimationFrame(animate);
            }

            triggerSpiralAnimation(parabolicSpiral);
        });
    </script>
</body>
</html>

