<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Removed "METAMETRIX" from title -->
  <title></title>
  <style>
    * {
      box-sizing: border-box;
      cursor: crosshair !important;
    }

    html, body {
      margin: 0;
      padding: 0;
      background-color: black;
      overflow: hidden;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    /* This style was for the removed nav-button div */
    #nav-button {
      z-index: 9999;
      position: absolute;
      font-size: 5rem;
      color: white;
      border: 1px solid transparent;
      font-family: 'Space Grotesk', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      box-shadow: 0 0 5px transparent;
      animation: fade-in 20s ease-out forwards;
      transition: box-shadow 0.3s ease-in-out;
      background-color: transparent;
      top: 10px;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    @keyframes fade-in {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    #nav-button-1, #nav-button-2 {
      padding: 40px;
      position: absolute;
      font-size: 2rem;
      color: white;
      border: 1px solid transparent;
      font-family: 'Space Grotesk', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      opacity: 0;
      pointer-events: auto;
      z-index: 10;
      transition: opacity 0.3s ease, top 0.3s ease;
      transform: translateX(-50%) translateY(-50%);
      text-decoration: none; 
    }

    #nav-button-1:hover { opacity: 1; top: 10%; color: #00FFFF; }
    #nav-button-2:hover { opacity: 1; top: 90%; color: #FF007A; }

    #nav-button-1 { top: 20%; left: 50%; }
    #nav-button-2 { top: 80%; left: 50%; }

    button, a {
      cursor: default !important;
    }
  </style>
  <!-- Removed an extra stray </style> tag that was here -->
</head>
<body>  

    <canvas id="canvas"></canvas>

    <!-- Removed div with id="nav-button" and text "METAMETRIX" -->

    <!-- Removed text "FIELD" from this link -->
    <a href="asen.html" id="nav-button-1">
    </a>
    <!-- Removed text "FRAME" from this link -->
    <a href="disen.html" id="nav-button-2">
    </a>
  
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let buttonHoverTimers = {
        navButton1: 0,
        navButton2: 0
      };
  
      // Cursor Position Tracking
      const cursor = { x: -9999, y: -9999 }; // Start offscreen
  
      window.addEventListener("mousemove", (event) => {
        cursor.x = event.clientX;
        cursor.y = event.clientY;

        const updateTimer = (el, key) => {
          if (!el) return; // Added check in case element doesn't exist
          const rect = el.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const dx = cx - cursor.x;
          const dy = cy - cursor.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150) {
            buttonHoverTimers[key] += 1;
          } else {
            buttonHoverTimers[key] = Math.max(0, buttonHoverTimers[key] - 2); // cool off
          }
        };

        updateTimer(navButton1, "navButton1");
        updateTimer(navButton2, "navButton2");
      });

  
      // Phase logic
      let currentPhase = 0;
      let nextPhase = 1;
      let transitionT = 0;              
      const transitionSpeed = 1 / 240;  
      const phaseDuration = 6000;       
  
      // const phaseNames = ["Outer (Chaos)", "Compress", "Expand"]; // Text removed
  
      const numParticles = {
        deep: 100,  
        fluid: 200, 
        pulse: 100  
      };
  
      // **Color Blending Function**
      function interpolateColor(color1, color2, t) {
        if (!color1 || !color2) return "rgb(255, 255, 255)";
  
        let c1 = color1.match(/\d+/g).map(Number);
        let c2 = color2.match(/\d+/g).map(Number);
  
        if (!c1 || !c2 || c1.length < 3 || c2.length < 3) return "rgb(255, 255, 255)";
  
        let r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
        let g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
        let b = Math.round(c1[2] + (c2[2] - c1[2]) * t);
  
        return `rgb(${r}, ${g}, ${b})`;
      }
  
// **Phase-Based Color Definitions**
function getPhaseColor(layer) {
  const phaseColors = {
    0: { 
      deep: "rgb(255, 0, 122)",  // Hot Pink - The Myth (phase 0)
      fluid: "rgb(255, 200, 87)", // Amber - The Flame (phase 0)
      pulse: "rgb(0, 255, 255)"   // Cyan - The Signal (phase 0)
    },
    1: { 
      deep: "rgb(0, 255, 255)",   // Cyan - The Signal (phase 1)
      fluid: "rgb(255, 200, 87)", // Amber - The Flame (phase 1)
      pulse: "rgb(255, 0, 122)"   // Hot Pink - The Myth (phase 1)
    },
    2: { 
      deep: "rgb(255, 200, 87)",  // Amber - The Flame (phase 2)
      fluid: "rgb(0, 255, 255)",  // Cyan - The Signal (phase 2)
      pulse: "rgb(255, 0, 122)"   // Hot Pink - The Myth (phase 2)
    }
  };

  let currentColor = phaseColors[currentPhase][layer];
  let targetColor = phaseColors[nextPhase][layer];
  return interpolateColor(currentColor, targetColor, transitionT);
}

// **Base Color for Each Layer**
function getBaseColor(layer) {
  return {
    deep: "rgb(255, 0, 122)",   // Hot Pink - The Myth (base color for deep)
    fluid: "rgb(0, 255, 255)",  // Cyan - The Signal (base color for fluid)
    pulse: "rgb(255, 200, 87)"  // Amber - The Flame (base color for pulse)
  }[layer] || "rgb(255, 255, 255)";  // Default color if the layer is unknown
}

function applySacredSpiral(particle, buttonEl, intensity, radius) {
  if (!buttonEl) return; // Added check
  const rect = buttonEl.getBoundingClientRect();
  const bx = rect.left + rect.width / 2;
  const by = rect.top + rect.height / 2;
  const canvasRect = canvas.getBoundingClientRect();
  const x = bx - canvasRect.left;
  const y = by - canvasRect.top;

  const dx = x - particle.x;
  const dy = y - particle.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < radius && intensity > 0.2) {
    // Normalize vector from center to particle
    const angle = Math.atan2(dy, dx) + Math.PI / 2; // Tangential spin
    const spiralForce = 0.05 * intensity * (1 - dist / radius); // Tighter near center

    particle.vx += Math.cos(angle) * spiralForce;
    particle.vy += Math.sin(angle) * spiralForce;
  }
}

          // Button Radiance: Affect particles near nav buttons
          function applyButtonRadiance(particle, buttonEl, intensity, radius) {
  if (!buttonEl) return; // Added check
  const rect = buttonEl.getBoundingClientRect();
  const bx = rect.left + rect.width / 2;
  const by = rect.top + rect.height / 2;

  const dx = bx - particle.x;
  const dy = by - particle.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

if (dist < radius) {
  let force = intensity * (1 - dist / radius);

  // Standard pull-in
  particle.vx += (dx / dist) * force;
  particle.vy += (dy / dist) * force;

  // Optional: add tangential force for orbit-like spin
  const spinForce = force * 0.5;
  particle.vx += (-dy / dist) * spinForce;
  particle.vy += (dx / dist) * spinForce;
}

}

function drawButtonHalo(buttonEl, intensity, color) {
  if (!buttonEl) return; // Added check
  const rect = buttonEl.getBoundingClientRect();
  const bx = rect.left + rect.width / 2;
  const by = rect.top + rect.height / 2;
  const canvasRect = canvas.getBoundingClientRect();
  const x = bx - canvasRect.left;
  const y = by - canvasRect.top;

  ctx.beginPath();
  ctx.arc(x, y, 80 + intensity * 100, 0, Math.PI * 2);
  ctx.strokeStyle = color;
  ctx.lineWidth = 2 + intensity * 8;
//   ctx.globalAlpha = intensity * 0.1;
ctx.globalAlpha = Math.pow(intensity, 1.5);
  ctx.stroke();
  ctx.globalAlpha = 1.0;
}
  
      // **Particle Class**
      class Particle {
        constructor(layer) {
          this.layer = layer;
          this.reset();
        }
  
        reset() {
          let spawnRadius = Math.min(canvas.width, canvas.height) / 2;
          
          if (this.layer === "deep") {
  // Deep layer logic: particles placed in a circle around the center
  let angle = Math.random() * Math.PI * 2;
  let radius = Math.random() * (spawnRadius * 0.6);
  this.x = canvas.width / 2 + Math.cos(angle) * radius;
  this.y = canvas.height / 2 + Math.sin(angle) * radius;
  this.vx = (Math.random() - 0.5) * 1;
  this.vy = (Math.random() - 0.5) * 1;
  this.size = 6;
} else if (this.layer === "fluid") {
  // Fluid layer logic: particles randomly placed across the canvas
  this.x = Math.random() * canvas.width;
  this.y = Math.random() * canvas.height;
  this.vx = (Math.random() - 0.5) * 4;
  this.vy = (Math.random() - 0.5) * 4;
  this.size = 1;
} else if (this.layer === "pulse") {
  // Pulse layer logic: particles randomly placed across the canvas
  this.x = Math.random() * canvas.width;
  this.y = Math.random() * canvas.height;
  this.vx = (Math.random() - 0.5) * 6;
  this.vy = (Math.random() - 0.5) * 6;
  this.size = 3;
}
        }
  
        update(particles,intensity1, intensity2) {
          switch (currentPhase) {
            case 0: // Outer Chaos
              this.vx += (Math.random() - 0.5) * 0.5;
              this.vy += (Math.random() - 0.5) * 0.5;
              break;
  
            case 1: // Compression Phase - Pull toward center
              let centerX = canvas.width / 2;
              let centerY = canvas.height / 2;
              let dx = centerX - this.x;
              let dy = centerY - this.y;
              let pullStrength = this.layer === "deep" ? 0.003 : 0.002;
              this.vx += dx * pullStrength;
              this.vy += dy * pullStrength;
              break;
  
            case 2: // Expansion
              for (let other of particles) {
                if (other === this) continue;
                let dx = other.x - this.x;
                let dy = other.y - this.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 80) {
                  this.vx += (Math.random() - 0.5) * 0.2;
                  this.vy += (Math.random() - 0.5) * 0.2;
                }
              }
              break;
          }

  
          // **Cursor Repulsion**
          let mouseDx = this.x - cursor.x;
          let mouseDy = this.y - cursor.y;
          let mouseDist = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
  
          if (mouseDist < 200) {  
            let pushStrength = 2 * (1 - mouseDist / 150); 
            this.vx += (mouseDx / mouseDist) * pushStrength;
            this.vy += (mouseDy / mouseDist) * pushStrength;
          }

const phaseModifier = currentPhase === 1 ? 2 : 1;
const baseIntensity = 0.04; // subtle always-on aura
applyButtonRadiance(this, navButton1, intensity1, 200);
applyButtonRadiance(this, navButton2, intensity2, 200);

applySacredSpiral(this, navButton1, intensity1, 150);
applySacredSpiral(this, navButton2, intensity2, 150);
  
          // Speed limit enforcement
          let maxSpeed = this.layer === "deep" ? 1 : this.layer === "fluid" ? 2 : 4;
          let speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
          if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
          }
  
          // Apply motion
          this.x += this.vx;
          this.y += this.vy;
  
          // Wrap particles at edges
          if (this.x < 0) this.x = canvas.width;
          if (this.x > canvas.width) this.x = 0;
          if (this.y < 0) this.y = canvas.height;
          if (this.y > canvas.height) this.y = 0;
        }
  
        draw() {
        let speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
  
        let baseColor = getBaseColor(this.layer);
        let phaseColor = getPhaseColor(this.layer);
  
        if (!baseColor || !phaseColor) return;
  
  
        // Step 1: Phase-based color blend
        let phaseBlend = interpolateColor(baseColor, phaseColor, transitionT);
  
        // Step 2: Motion shimmer only kicks in with transition progress
        let shimmerWeight = transitionT * Math.min(speed / 4, 1); // dampens early
  
        let finalBlend = interpolateColor(baseColor, phaseBlend, shimmerWeight);
  
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
        ctx.fillStyle = finalBlend;
        ctx.fill();
        ctx.shadowColor = finalBlend;
        }
      }
  
      // **Initialize Particles**
      const particles = [];
  
      for (let i = 0; i < numParticles.deep; i++) {
        particles.push(new Particle("deep"));
      }
      for (let i = 0; i < numParticles.fluid; i++) {
        particles.push(new Particle("fluid"));
      }
      for (let i = 0; i < numParticles.pulse; i++) {
        particles.push(new Particle("pulse"));
      }
  
      // **Hover Glow Effect**
      // const navButton = document.getElementById("nav-button"); // Removed this line, element no longer exists
      const navButton1 = document.getElementById("nav-button-1");
      const navButton2 = document.getElementById("nav-button-2");
  
      // Removed event listeners referencing the deleted "navButton" element
      // navButton1.addEventListener("mouseenter", () => { ... });
      // navButton2.addEventListener("mouseenter", () => { ... });
      // navButton1.addEventListener("mouseleave", () => { ... });
      // navButton2.addEventListener("mouseleave", () => { ... });
  
      animate();
  
      function animate() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.07)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        transitionT += transitionSpeed;
        if (transitionT > 1) transitionT = 1;

        // 🔮 Calculate aura strength from dwell
        const baseIntensity = 0.03;
        const intensity1 = baseIntensity + Math.min(buttonHoverTimers.navButton1 / 100, 1) * 0.3;
        const intensity2 = baseIntensity + Math.min(buttonHoverTimers.navButton2 / 100, 1) * 0.3;

        // 🌌 Draw aura halos
        drawButtonHalo(navButton1, intensity1, 'rgba(255,0,122,1)');
        drawButtonHalo(navButton2, intensity2, 'rgba(0,255,255,1)');

        // ✨ Reveal buttons based on attention threshold
        if (navButton1) {
          navButton1.style.opacity = Math.min(intensity1 * 2, 1); // gentle fade
        }
        if (navButton2) {
          navButton2.style.opacity = Math.min(intensity2 * 2, 1);
        }

        // 🧬 Update & draw particles
        particles.forEach(p => {
          p.update(particles, intensity1, intensity2);
          p.draw();
        });

        requestAnimationFrame(animate);
      }
  
      // Redundant animate() call removed
  
      setInterval(() => {
        currentPhase = nextPhase;
        nextPhase = (nextPhase + 1) % 3;
        transitionT = 0;
      }, phaseDuration);
  
    </script>
</body>
</html>
