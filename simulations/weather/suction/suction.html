<!DOCTYPE html>
<html>
<head>
    <title>Subduction [Idle Mechanics]</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* ===========================================
         * ESTILOS COMPLETOS EMBUTIDOS (Baseado no tema)
         * =========================================== */

        /* 1. Variáveis e Base */
        :root {
          /* Paleta de cores do tema para UI */
          --im-color-primary: #ff0090;  
          --im-color-secondary: #fff204;
          --im-color-tertiary: #09ff00; 
          --im-color-bg: #0D0D0D;       
          --im-color-text: #BBBBBB;      
          --im-color-ui-bg: rgba(20, 20, 20, 0.7);
        }

        body {
            margin: 0;
            overflow: hidden;
            display: flex; 
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--im-color-bg);
            color: var(--im-color-text);
            font-family: 'Inter', sans-serif;
        }

        html, body {
           height: 100%;
           width: 100%;
        }
        
        canvas {
            display: block; 
            position: absolute; 
            top: 0;
            left: 0;
            z-index: 1; /* Atrás da UI */
            /* ATUALIZAÇÃO: Cursor 'none' para corresponder ao furacão */
            cursor: none; 
            width: 100%;  
            height: 100%; 
        }

        /* 2. Controles (UI unificada) */
        
        .im-controls {
          position: absolute;
          z-index: 100; 
          background-color: var(--im-color-ui-bg);
          border: 1px solid var(--im-color-tertiary);
          border-radius: 8px;
          padding: 15px;
          display: flex;
          gap: 15px;
          backdrop-filter: blur(5px);
          -webkit-backdrop-filter: blur(5px);
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
          opacity: 1 !important; 
          visibility: visible !important; 
        }

         #controls-top-container {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row; 
        }

        #controls-bottom-container {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row; 
        }

         .im-button {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 44px;
          height: 44px;
          border-radius: 50%;
          padding: 0;
          background-color: transparent;
          border: 2px solid var(--im-color-primary);
          color: var(--im-color-primary);
          cursor: pointer;
          transition: all 0.2s ease;
          z-index: 101; 
        }
        .im-button:hover {
          color: var(--im-color-text);
          border-color: var(--im-color-secondary);
          box-shadow: 0 0 12px 2px var(--im-color-primary);
          transform: scale(1.05);
        }
        .im-button.active {
          background-color: rgba(187, 187, 187, 0.2); 
          box-shadow: 0 0 12px 2px var(--im-color-text); 
          border-color: var(--im-color-text);
          color: var(--im-color-text);
        }

        /* Sliders */
        .im-controls input[type="range"] {
          -webkit-appearance: none;
          appearance: none;
          background: transparent;
          cursor: pointer;
          width: 75px; 
          margin: 0;
          display: inline-block !important; 
          visibility: visible !important;
        }
        .im-controls input[type="range"]::-webkit-slider-runnable-track {
          background: rgba(187, 187, 187, 0.5); 
          height: 4px; 
          border-radius: 2px;
        }
        .im-controls input[type="range"]::-moz-range-track {
           background: rgba(187, 187, 187, 0.5); 
          height: 4px; 
          border-radius: 2px;
        }
        .im-controls input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          margin-top: -8px; 
          background-color: var(--im-color-text); 
          border: 2px solid var(--im-color-bg); 
          height: 20px; 
          width: 12px; 
          border-radius: 3px; 
          box-shadow: 0 0 5px 0 rgba(187, 187, 187, 0.5); 
          transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.1s ease;
        }
        .im-controls input[type="range"]::-moz-range-thumb {
          background-color: var(--im-color-text); 
          border: 2px solid var(--im-color-bg); 
          height: 20px;
          width: 12px;
          border-radius: 3px;
          box-shadow: 0 0 5px 0 rgba(187, 187, 187, 0.5); 
          transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.1s ease;
        }
        .im-controls input[type="range"]:hover::-webkit-slider-thumb {
          transform: scale(1.1);
          background-color: var(--im-color-secondary); 
          box-shadow: 0 0 8px 0 var(--im-color-secondary); 
        }
        .im-controls input[type="range"]:hover::-moz-range-thumb {
          transform: scale(1.1);
           background-color: var(--im-color-secondary); 
          box-shadow: 0 0 8px 0 var(--im-color-secondary); 
        }

    </style>
</head>
<body>
    <canvas id="simulationCanvas"></canvas>

    <!-- UI (Inalterada) -->
    <div id="controls-top-container" class="im-controls">
         <button id="actionButton" class="im-button"></button>
    </div>
    
    <div id="controls-bottom-container" class="im-controls">
        <input type="range" id="emergenceRate" name="emergenceRate" min="0" max="100" value="50">
        <input type="range" id="temporalFlow" name="temporalFlow" min="0" max="100" value="50">
        <input type="range" id="surfaceInfluence" name="surfaceInfluence" min="0" max="100" value="40">
    </div>

    <script>
        // --- Canvas Setup ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const actionButton = document.getElementById('actionButton'); 

        // --- Mouse Tracking ---
        let mouseX = 0;
        let mouseY = 0;
        let isMouseOverCanvas = false; 

        // --- Color Helper Functions ---
        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 }; 
        }
        function lerpColor(rgb1, rgb2, factor) {
           factor = Math.max(0, Math.min(1, factor)); 
           const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
           const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
           const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);
           return { r, g, b };
        }
        function mapRange(value, inMin, inMax, outMin, outMax) {
           value = Math.max(inMin, Math.min(inMax, value));
           return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
        }

        // --- ATUALIZAÇÃO: Paleta de Cores ---
        // Modificada para ser mais escura e corresponder ao tema
        const PALETTE = {
            deepSpace: '#0b192f',     // Azul mais escuro e profundo
            electricBlue: '#1e3a8a',  // Menos "elétrico"
            brightCyan: '#0e7490',    // Mais suave
            solarFlare: '#fff204',    // Cor secundária do tema
            sunYellow: '#fde047',     // Amarelo mais suave
            whiteHot: '#fef9c3',      // Topo da gama suave
            sparklePink: '#ff0090',   // Cor primária do tema
            // Lista de cores atualizada
            stormColors: ['#0b192f', '#1e3a8a', '#0e7490', '#fde047', '#fef9c3'],
            starColor: '#FFFFFF' 
        };
        const PALETTE_RGB = {};
        for (const key in PALETTE) {
            if (typeof PALETTE[key] === 'string' && PALETTE[key].startsWith('#')) {
                PALETTE_RGB[key] = hexToRgb(PALETTE[key]);
            }
        }
        PALETTE_RGB.stormColorsRgb = PALETTE.stormColors.map(hex => hexToRgb(hex));
        // Cor de fundo global
        let canvasBgColor = '#0D0D0D'; 

        // --- Simulation Parameters ---
        let PARAMS = {
             MAX_ACTIVE_STORMS: 15,          
             STORM_SPAWN_PROBABILITY: 0.01, 
             MIN_LIFESPAN: 800,              
             MAX_LIFESPAN_VARIATION: 1200,   
             TIME_SCALE: 0.01,               
             STORM_MERGE_ENABLED: true,      
             STORM_MERGE_DISTANCE_FACTOR: 0.8, 
             MIN_MAX_STRENGTH: 0.08,         
             MAX_STRENGTH_VARIATION: 0.08,   
             MIN_MAX_RADIUS: 150,            
             MAX_RADIUS_VARIATION: 150,      
             MIN_EYE_RADIUS: 5,              
             MAX_EYE_RADIUS_VARIATION: 20,   
             MIN_VX: -0.3,                   
             MAX_VX_VARIATION: -0.4,         
             MIN_VY: -0.05,                  
             MAX_VY_VARIATION: 0.1,          
             NORTHWARD_TURN_STRENGTH: 0.3,   
             NORTHWARD_TURN_Y_THRESHOLD: 0,  
             LAND_RECT: { x: 0, y: 0, width: 0, height: 0 }, 
             LAND_DISSIPATION_FACTOR: 5.0,   
             FORMATION_Y_MIN: 0, FORMATION_Y_MAX: 0,
             FORMATION_X_MIN: 0, FORMATION_X_MAX: 0,
             BASE_PARTICLE_COUNT: 400,       
             PARTICLES_PER_STRENGTH: 10000,  
             PARTICLE_RADIUS: 1.0,           
             INWARD_PULL_FACTOR: 1.0,        
             OUTWARD_EYE_FACTOR: 0.3,        
             DAMPING: 0.96,                  
             MAX_SPEED: 7.0,                 
             PARTICLE_BASE_LIFESPAN: 250,    
             PARTICLE_LIFESPAN_VARIATION: 150,
             INNER_REMOVAL_RADIUS_FACTOR: 1.5, 
             trailLength: 6,                 
             // ATUALIZAÇÃO: Alpha base menor para focar no brilho
             particleBaseAlpha: 0.6,         
             trailAlphaFactor: 0.6,          
             sizeSpeedFactor: 0.5,           
             alphaSpeedFactor: 0.3,          
             // ATUALIZAÇÃO: Brilho maior para visual "volumétrico"
             PARTICLE_GLOW_BLUR: 12,         
             SPARKLE_CHANCE: 0.02,           
             SPARKLE_GLOW_BLUR: 16,          
             SPEED_COLOR_FACTOR: 0.8,        
             MAX_TOTAL_PARTICLES: 20000,     
             MOTHER_STRENGTH_MULT: 1.8,      
             MOTHER_RADIUS_MULT: 1.6,        
             MOTHER_LIFESPAN_MULT: 1.5,      
             MOUSE_ENABLED: true,            
             MOUSE_FORCE_TYPE: 'repel',      
             MOUSE_STORM_INFLUENCE_RADIUS: 300, 
             MOUSE_PARTICLE_INTERACTION_RADIUS: 100, 
             MOUSE_PARTICLE_CHECK_COUNT: 35, 
             MOUSE_FORCE_STRENGTH: 80        
        };
        PARAMS.MOUSE_STORM_INFLUENCE_RADIUS_SQ = PARAMS.MOUSE_STORM_INFLUENCE_RADIUS ** 2;
        PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS_SQ = PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS ** 2;

        // --- REMOVIDO: Parâmetros do Starfield ---

        // --- Global State ---
        let activeStorms = []; 
        let currentTime = 0; 
        let nextStormId = 0; 
        // --- REMOVIDO: stars = [] ---
        let currentTotalParticles = 0; 

        // --- Vector Helpers ---
        const Vector = { limit: (vx, vy, max) => { const magSq = vx * vx + vy * vy; if (magSq > max * max && max > 0) { const mag = Math.sqrt(magSq); return { x: (vx / mag) * max, y: (vy / mag) * max }; } return { x: vx, y: vy }; } };

        // --- Helper Function: Get Smooth Storm Color ---
         function getSmoothStormColorRgb(currentStrength, maxStrength) { 
            const colors = PALETTE_RGB.stormColorsRgb; 
            if (maxStrength <= 0) { return colors[0]; } 
            const strengthRatio = Math.min(1, Math.max(0, currentStrength / maxStrength)); 
            const maxIndex = colors.length - 1; 
            const scaledRatio = strengthRatio * maxIndex; 
            const index1 = Math.min(maxIndex - 1, Math.floor(scaledRatio)); 
            const index2 = index1 + 1; 
            const segmentFactor = scaledRatio - index1; 
            return lerpColor(colors[index1], colors[index2], segmentFactor); 
         }

        // --- Storm Class ---
        class Storm { 
            constructor(initialX, initialY) {
                this.id = nextStormId++; 
                this.x = initialX !== undefined ? initialX : PARAMS.FORMATION_X_MIN + Math.random() * (PARAMS.FORMATION_X_MAX - PARAMS.FORMATION_X_MIN);
                this.y = initialY !== undefined ? initialY : PARAMS.FORMATION_Y_MIN + Math.random() * (PARAMS.FORMATION_Y_MAX - PARAMS.FORMATION_Y_MIN);
                this.vx = PARAMS.MIN_VX + Math.random() * PARAMS.MAX_VX_VARIATION;
                this.vy = PARAMS.MIN_VY + Math.random() * PARAMS.MAX_VY_VARIATION;
                this.maxLifespan = PARAMS.MIN_LIFESPAN + Math.random() * PARAMS.MAX_LIFESPAN_VARIATION;
                this.maxStrength = PARAMS.MIN_MAX_STRENGTH + Math.random() * PARAMS.MAX_STRENGTH_VARIATION;
                this.maxRadius = PARAMS.MIN_MAX_RADIUS + Math.random() * PARAMS.MAX_RADIUS_VARIATION;
                this.eyeRadius = PARAMS.MIN_EYE_RADIUS + Math.random() * PARAMS.MAX_EYE_RADIUS_VARIATION;
                this.age = 0;
                this.currentStrength = 0;
                this.currentRadius = this.eyeRadius * 2; 
                this.targetParticleCount = 0;
                this.particles = []; 
                this.state = 'forming'; 
                this.isOnLand = false; 
                this.baseColorRgb = PALETTE_RGB.stormColorsRgb[0]; 
            }

            update(deltaTime) {
                this.isOnLand = ( this.x > PARAMS.LAND_RECT.x && this.x < PARAMS.LAND_RECT.x + PARAMS.LAND_RECT.width && this.y > PARAMS.LAND_RECT.y && this.y < PARAMS.LAND_RECT.y + PARAMS.LAND_RECT.height );
                this.age += deltaTime * (this.isOnLand ? PARAMS.LAND_DISSIPATION_FACTOR : 1.0);
                const lifeRatio = Math.min(1, this.age / this.maxLifespan);

                let strengthRatio = 0;
                if (lifeRatio < 0.2) { strengthRatio = (lifeRatio / 0.2) * 0.8; this.state = 'forming';
                } else if (lifeRatio < 0.7) { strengthRatio = 0.8 + (lifeRatio - 0.2) / 0.5 * 0.2; this.state = 'active';
                } else { strengthRatio = 1.0 - ((lifeRatio - 0.7) / 0.3); this.state = 'dissipating'; }
                strengthRatio = Math.max(0, Math.min(1, strengthRatio)); 

                this.currentStrength = this.maxStrength * strengthRatio * (this.isOnLand ? 0.5 : 1.0); 
                this.currentRadius = this.eyeRadius + (this.maxRadius - this.eyeRadius) * strengthRatio; 
                this.baseColorRgb = getSmoothStormColorRgb(this.currentStrength, this.maxStrength);

                let targetVy = this.vy;
                if (this.y < PARAMS.NORTHWARD_TURN_Y_THRESHOLD) { const curveFactor = (PARAMS.NORTHWARD_TURN_Y_THRESHOLD - this.y) / PARAMS.NORTHWARD_TURN_Y_THRESHOLD; targetVy -= curveFactor * PARAMS.NORTHWARD_TURN_STRENGTH * Math.abs(this.vx); }
                this.vy += (targetVy - this.vy) * 0.01 * deltaTime; 
                this.x += this.vx * deltaTime; this.y += this.vy * deltaTime;

                this.targetParticleCount = Math.floor(PARAMS.BASE_PARTICLE_COUNT + this.currentStrength * PARAMS.PARTICLES_PER_STRENGTH);
                const particlesToAdd = this.targetParticleCount - this.particles.length;

                if (particlesToAdd > 0 && this.state !== 'dissipating') { for (let i = 0; i < Math.min(particlesToAdd, 50); i++) { this.addParticle(); } }

                if (this.age > this.maxLifespan || (this.state === 'dissipating' && this.particles.length < PARAMS.BASE_PARTICLE_COUNT * 0.1) || this.x < -this.currentRadius * 2.5 || this.x > canvas.width + this.currentRadius * 2.5 || this.y < -this.currentRadius * 2.5 || this.y > canvas.height + this.currentRadius * 2.5) { return false; }
                return true; 
             }

            addParticle() {
                if (currentTotalParticles >= PARAMS.MAX_TOTAL_PARTICLES) { return; }
                const angle = Math.random() * Math.PI * 2; const radius = this.currentRadius * (0.9 + Math.random() * 0.3); const x = this.x + Math.cos(angle) * radius; const y = this.y + Math.sin(angle) * radius; const isSparkle = Math.random() < PARAMS.SPARKLE_CHANCE;
                this.particles.push({ x, y, vx: this.vx, vy: this.vy, alpha: PARAMS.particleBaseAlpha * (0.7 + Math.random() * 0.3), history: [], stormId: this.id, age: 0, maxAge: PARAMS.PARTICLE_BASE_LIFESPAN + Math.random() * PARAMS.PARTICLE_LIFESPAN_VARIATION, isSparkle: isSparkle });
                currentTotalParticles++; 
            }

            calculateForce(p) {
                let forceX = 0, forceY = 0; const dx = this.x - p.x; const dy = this.y - p.y; const distSq = dx * dx + dy * dy; const dist = Math.sqrt(distSq); 
                if (dist > 1) { const normalizedX = dx / dist; const normalizedY = dy / dist; let rotationMag = this.currentStrength * (1 - dist / (this.currentRadius * 1.5)); rotationMag = Math.min(rotationMag, this.currentStrength * 1.2); rotationMag = Math.max(0, rotationMag); forceX += -normalizedY * rotationMag; forceY += normalizedX * rotationMag;
                    if (dist < this.eyeRadius) { let eyePush = (1 - dist / this.eyeRadius) * this.currentStrength * PARAMS.OUTWARD_EYE_FACTOR; forceX += -normalizedX * eyePush; forceY += -normalizedY * eyePush;
                    } else if (dist < this.currentRadius * 1.2) { let inwardMag = this.currentStrength * PARAMS.INWARD_PULL_FACTOR * Math.pow(dist / this.currentRadius, 0.5); inwardMag = Math.min(inwardMag, this.currentStrength * PARAMS.INWARD_PULL_FACTOR * 1.5); inwardMag = Math.max(0, inwardMag); forceX += normalizedX * inwardMag; forceY += normalizedY * inwardMag; }
                } return { x: forceX, y: forceY };
            }

            updateParticles(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i]; const force = this.calculateForce(p); p.age += deltaTime; p.vx += force.x * deltaTime; p.vy += force.y * deltaTime; p.vx *= PARAMS.DAMPING; p.vy *= PARAMS.DAMPING; const limitedVel = Vector.limit(p.vx, p.vy, PARAMS.MAX_SPEED); p.vx = limitedVel.x; p.vy = limitedVel.y; p.x += p.vx * deltaTime; p.y += p.vy * deltaTime; p.history.push({ x: p.x, y: p.y }); if (p.history.length > PARAMS.trailLength) { p.history.shift(); }
                    const distToCenterSq = (p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y); const distToCenter = Math.sqrt(distToCenterSq); let shouldFade = false;
                    if (p.age > p.maxAge || (distToCenter < this.eyeRadius * PARAMS.INNER_REMOVAL_RADIUS_FACTOR && p.age > PARAMS.PARTICLE_BASE_LIFESPAN * 0.2) || distToCenterSq > (this.currentRadius * 2.2) ** 2 || this.state === 'dissipating') { shouldFade = true; }
                    if (shouldFade) { p.alpha *= (0.93 - (deltaTime * 0.05)); if (p.alpha < 0.02) { this.particles.splice(i, 1); currentTotalParticles--; }
                    } else { if (p.alpha < PARAMS.particleBaseAlpha * 0.8) p.alpha += 0.05 * deltaTime; p.alpha = Math.min(p.alpha, PARAMS.particleBaseAlpha); }
                }
            }

            draw(ctx) {
                const originalShadowBlur = ctx.shadowBlur; const originalShadowColor = ctx.shadowColor;
                this.particles.forEach(p => {
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy); const speedRatio = Math.min(1, speed / PARAMS.MAX_SPEED); const dynamicAlpha = p.alpha * (1 + speedRatio * PARAMS.alphaSpeedFactor); 
                    const finalAlpha = Math.min(1, dynamicAlpha); 
                    const dynamicRadius = PARAMS.PARTICLE_RADIUS * (1 + speedRatio * PARAMS.sizeSpeedFactor);
                    
                    let particleRgb, particleGlowBlur, particleColorStyle;

                    if (p.isSparkle) { 
                        particleRgb = PALETTE_RGB.sparklePink; 
                        particleColorStyle = `rgb(${particleRgb.r},${particleRgb.g},${particleRgb.b})`; 
                        particleGlowBlur = PARAMS.SPARKLE_GLOW_BLUR;
                    } else { 
                        particleRgb = lerpColor(this.baseColorRgb, PALETTE_RGB.whiteHot, speedRatio * PARAMS.SPEED_COLOR_FACTOR); 
                        particleColorStyle = `rgb(${particleRgb.r},${particleRgb.g},${particleRgb.b})`; 
                        particleGlowBlur = PARAMS.PARTICLE_GLOW_BLUR; 
                    }
                    
                    // ATUALIZAÇÃO: Tornar o núcleo da partícula fraco e o brilho forte
                    const coreAlpha = finalAlpha * 0.2; // Núcleo muito fraco
                    const trailBaseAlpha = finalAlpha * PARAMS.trailAlphaFactor * 0.5; // Trilhas mais fracas
                    
                    // Desenhar trilha
                    if (p.history.length > 1) { 
                        ctx.shadowBlur = 0; // Sem brilho para a trilha
                        ctx.beginPath(); 
                        ctx.moveTo(p.history[0].x, p.history[0].y); 
                        for (let i = 1; i < p.history.length; i++) { 
                            ctx.lineTo(p.history[i].x, p.history[i].y); 
                        } 
                        const trailAlpha = trailBaseAlpha * (p.history.length / PARAMS.trailLength); 
                        ctx.strokeStyle = `rgba(${particleRgb.r}, ${particleRgb.g}, ${particleRgb.b}, ${trailAlpha})`; 
                        ctx.lineWidth = dynamicRadius * 0.8; 
                        ctx.lineCap = "round"; 
                        ctx.stroke(); 
                    }
                    
                    // Desenhar partícula (o brilho é o principal)
                    ctx.shadowBlur = particleGlowBlur; // Brilho forte
                    ctx.shadowColor = particleColorStyle; // Cor total do brilho
                    ctx.beginPath(); 
                    ctx.arc(p.x, p.y, dynamicRadius, 0, Math.PI * 2); 
                    // O preenchimento é muito transparente, o brilho faz o trabalho
                    ctx.fillStyle = `rgba(${particleRgb.r}, ${particleRgb.g}, ${particleRgb.b}, ${coreAlpha})`; 
                    ctx.fill();
                });
                ctx.shadowBlur = originalShadowBlur; ctx.shadowColor = originalShadowColor;
            }
        }

        // --- REMOVIDO: Funções Starfield ---

        // --- NOVO: Retículo do Mouse ---
        function drawMouseReticle(ctx) {
            if (!isMouseOverCanvas) return;

            const crosshairSize = 10;
            const targetRgb = (PARAMS.MOUSE_FORCE_TYPE === 'repel') ? 
                hexToRgb(PALETTE.sparklePink) : 
                hexToRgb(PALETTE.brightCyan);
            
            const colorStyle = `rgba(${targetRgb.r}, ${targetRgb.g}, ${targetRgb.b}, 0.8)`;
            const glowStyle = `rgba(${targetRgb.r}, ${targetRgb.g}, ${targetRgb.b}, 0.4)`;

            ctx.save();
            ctx.shadowBlur = 8;
            ctx.shadowColor = glowStyle;
            
            ctx.strokeStyle = colorStyle;
            ctx.lineWidth = 1.5;

            // Mira
            ctx.beginPath();
            ctx.moveTo(mouseX - crosshairSize, mouseY);
            ctx.lineTo(mouseX + crosshairSize, mouseY);
            ctx.moveTo(mouseX, mouseY - crosshairSize);
            ctx.lineTo(mouseX, mouseY + crosshairSize);
            ctx.stroke();
            
            // Círculo
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, crosshairSize * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }

        // --- Main Simulation Loop ---
        let lastTime = 0; 
        function animate(timestamp) {
            const elapsed = timestamp - lastTime; 
            const deltaTime = isNaN(elapsed) || elapsed <= 0 ? 1 : Math.min(3.0, elapsed / 16.667); 
            lastTime = timestamp;
            
            if (deltaTime > 0) {
                currentTime += deltaTime * PARAMS.TIME_SCALE; 
                
                // ATUALIZAÇÃO: Limpar com cor sólida, sem trilhas
                ctx.fillStyle = canvasBgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // REMOVIDO: drawStars(deltaTime); 

                if (PARAMS.MOUSE_ENABLED && isMouseOverCanvas) { 
                     activeStorms.forEach(storm => {
                        const stormDx = storm.x - mouseX; const stormDy = storm.y - mouseY; const stormDistSq = stormDx * stormDx + stormDy * stormDy;
                        if (stormDistSq < PARAMS.MOUSE_STORM_INFLUENCE_RADIUS_SQ && storm.particles.length > 0) {
                            const numToCheck = Math.min(PARAMS.MOUSE_PARTICLE_CHECK_COUNT, storm.particles.length);
                            for (let i = 0; i < numToCheck; i++) {
                                const pIndex = Math.floor(Math.random() * storm.particles.length); const p = storm.particles[pIndex]; if (!p) continue; 
                                const particleDx = p.x - mouseX; const particleDy = p.y - mouseY; const particleDistSq = particleDx * particleDx + particleDy * particleDy;
                                if (particleDistSq < PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS_SQ && particleDistSq > 1) { const dist = Math.sqrt(particleDistSq); const normX = particleDx / dist; const normY = particleDy / dist; let forceMag = PARAMS.MOUSE_FORCE_STRENGTH / (particleDistSq + 10); if (PARAMS.MOUSE_FORCE_TYPE === 'attract') { forceMag *= -1; } p.vx += normX * forceMag * deltaTime; p.vy += normY * forceMag * deltaTime; }
                            }
                        }
                    });
                }
                
                if (activeStorms.length < PARAMS.MAX_ACTIVE_STORMS && Math.random() < PARAMS.STORM_SPAWN_PROBABILITY) { activeStorms.push(new Storm()); }
                
                for (let i = activeStorms.length - 1; i >= 0; i--) {
                    const storm = activeStorms[i]; 
                    const keepStorm = storm.update(deltaTime); 
                    if (keepStorm) { 
                        storm.updateParticles(deltaTime); 
                        storm.draw(ctx); 
                    } 
                    else { 
                        currentTotalParticles -= storm.particles.length; 
                        currentTotalParticles = Math.max(0, currentTotalParticles); 
                        activeStorms.splice(i, 1); 
                    }
                }
                
                if (PARAMS.STORM_MERGE_ENABLED && activeStorms.length > 1) { 
                    let mergedIndices = new Set();
                    for (let i = 0; i < activeStorms.length; i++) {
                        for (let j = i + 1; j < activeStorms.length; j++) {
                            if (mergedIndices.has(i) || mergedIndices.has(j)) continue;
                            const stormA = activeStorms[i]; const stormB = activeStorms[j]; const distSq = (stormA.x - stormB.x)**2 + (stormA.y - stormB.y)**2; const mergeDist = (stormA.currentRadius + stormB.currentRadius) * PARAMS.STORM_MERGE_DISTANCE_FACTOR;
                            if (distSq < mergeDist * mergeDist) { const [survivor, absorbed, absorbedIndex] = stormA.currentStrength >= stormB.currentStrength ? [stormA, stormB, j] : [stormB, stormA, i]; survivor.particles.push(...absorbed.particles); survivor.maxStrength += absorbed.maxStrength * 0.5; survivor.maxLifespan += absorbed.maxLifespan * 0.25; mergedIndices.add(absorbedIndex); }
                        }
                    }
                    if (mergedIndices.size > 0) { activeStorms = activeStorms.filter((_, index) => !mergedIndices.has(index)); }
                }
            }
            
            // NOVO: Desenhar o retículo do mouse por cima de tudo
            drawMouseReticle(ctx);
            
            requestAnimationFrame(animate);
        }

        // --- Event Listeners ---
        actionButton.addEventListener('click', () => { 
            console.log('Initiating Subduction...'); activeStorms.forEach(storm => { currentTotalParticles -= storm.particles.length; }); currentTotalParticles = Math.max(0, currentTotalParticles); activeStorms = []; console.log('Storms cleared. Spawning mother storm...');
            if (currentTotalParticles < PARAMS.MAX_TOTAL_PARTICLES) { const motherStorm = new Storm(); motherStorm.maxStrength = (PARAMS.MIN_MAX_STRENGTH + PARAMS.MAX_STRENGTH_VARIATION) * PARAMS.MOTHER_STRENGTH_MULT; motherStorm.maxRadius = (PARAMS.MIN_MAX_RADIUS + PARAMS.MAX_RADIUS_VARIATION) * PARAMS.MOTHER_RADIUS_MULT; motherStorm.maxLifespan = (PARAMS.MIN_LIFESPAN + PARAMS.MAX_LIFESPAN_VARIATION) * PARAMS.MOTHER_LIFESPAN_MULT; activeStorms.push(motherStorm); console.log('Mother storm spawned:', motherStorm);
            } else { console.log('Particle cap reached, cannot spawn mother storm.'); }
        });
        canvas.addEventListener('click', (event) => { 
            if (activeStorms.length < PARAMS.MAX_ACTIVE_STORMS) { const rect = canvas.getBoundingClientRect(); const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top; activeStorms.push(new Storm(clickX, clickY)); }
        });
        canvas.addEventListener('mousemove', (event) => { 
             const rect = canvas.getBoundingClientRect(); mouseX = event.clientX - rect.left; mouseY = event.clientY - rect.top; isMouseOverCanvas = true; 
        });
        canvas.addEventListener('mouseleave', () => { isMouseOverCanvas = false; });
        window.addEventListener('keydown', (event) => { 
            if (event.key === 'f' || event.key === 'F') { PARAMS.MOUSE_FORCE_TYPE = PARAMS.MOUSE_FORCE_TYPE === 'repel' ? 'attract' : 'repel'; console.log(`Mouse force set to: ${PARAMS.MOUSE_FORCE_TYPE}`); }
        });
        canvas.addEventListener('wheel', (event) => { 
            event.preventDefault(); const scrollDelta = Math.sign(event.deltaY);
            if (scrollDelta > 0) { PARAMS.MOUSE_FORCE_STRENGTH = Math.max(10, PARAMS.MOUSE_FORCE_STRENGTH - 10); PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS = Math.max(30, PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS - 5);
            } else { PARAMS.MOUSE_FORCE_STRENGTH = Math.min(300, PARAMS.MOUSE_FORCE_STRENGTH + 10); PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS = Math.min(250, PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS + 5); }
            PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS_SQ = PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS ** 2; console.log(`Mouse Radius: ${PARAMS.MOUSE_PARTICLE_INTERACTION_RADIUS}, Strength: ${PARAMS.MOUSE_FORCE_STRENGTH}`);
        });

        // --- Resize Canvas ---
        function resizeCanvas() { 
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            PARAMS.NORTHWARD_TURN_Y_THRESHOLD = canvas.height * 0.5; PARAMS.LAND_RECT = { x: canvas.width * 0.75, y: 0, width: canvas.width * 0.25, height: canvas.height * 0.6 }; PARAMS.FORMATION_Y_MIN = canvas.height * 0.2; PARAMS.FORMATION_Y_MAX = canvas.height * 0.8; PARAMS.FORMATION_X_MIN = canvas.width * 0.2; PARAMS.FORMATION_X_MAX = canvas.width * 0.8;
            
            // REMOVIDO: initStars();
            
            // NOVO: Obter a cor de fundo das variáveis CSS
            canvasBgColor = getComputedStyle(document.documentElement).getPropertyValue('--im-color-bg') || '#0D0D0D';
        }

        // --- UI Controls Setup ---
        function setupControls() { 
            const emergenceRateSlider = document.getElementById('emergenceRate'); const temporalFlowSlider = document.getElementById('temporalFlow'); const surfaceInfluenceSlider = document.getElementById('surfaceInfluence');
            const emergenceRateRange = { outMin: 0.001, outMax: 0.05 }; const temporalFlowRange = { outMin: 0.002, outMax: 0.03 }; const surfaceInfluenceRange = { outMin: 0, outMax: 250 };    
            emergenceRateSlider.value = mapRange(PARAMS.STORM_SPAWN_PROBABILITY, emergenceRateRange.outMin, emergenceRateRange.outMax, 0, 100); temporalFlowSlider.value = mapRange(PARAMS.TIME_SCALE, temporalFlowRange.outMin, temporalFlowRange.outMax, 0, 100); surfaceInfluenceSlider.value = mapRange(PARAMS.MOUSE_FORCE_STRENGTH, surfaceInfluenceRange.outMin, surfaceInfluenceRange.outMax, 0, 100);
            emergenceRateSlider.addEventListener('input', (e) => { const val = parseFloat(e.target.value); PARAMS.STORM_SPAWN_PROBABILITY = mapRange(val, 0, 100, emergenceRateRange.outMin, emergenceRateRange.outMax); });
            temporalFlowSlider.addEventListener('input', (e) => { const val = parseFloat(e.target.value); PARAMS.TIME_SCALE = mapRange(val, 0, 100, temporalFlowRange.outMin, temporalFlowRange.outMax); });
            surfaceInfluenceSlider.addEventListener('input', (e) => { const val = parseFloat(e.target.value); PARAMS.MOUSE_FORCE_STRENGTH = mapRange(val, 0, 100, surfaceInfluenceRange.outMin, surfaceInfluenceRange.outMax); });
        }

        // --- Initial Setup & Start ---
        window.addEventListener('resize', resizeCanvas); 
        resizeCanvas(); 
        setupControls(); 
        requestAnimationFrame(animate); 

    </script>
</body>
</html>
