<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Iris [Simplified]</title>
  
  <!-- ADICIONADO: O novo arquivo de tema unificado -->
  <link rel="stylesheet" href="idle-mechanics-theme.css">
  
  <!-- ADICIONADO: Fonte 'Inter' para consistência -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  
  <style>
    /* Estilo de canvas mantido */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      /* ADDED: Set background color directly for simplicity */
      background-color: #000;
    }

  </style>
</head>
<body>
  <!-- Canvas da simulação (Inalterado) -->
  <canvas id="spiral-canvas"></canvas>

  <!-- 
    ATUALIZADO: 
    - O contêiner agora usa as classes de "Altar de Controle" do tema.
    - O .corner-top-left o posiciona corretamente.
  -->
  <div id="palette-switcher" class="im-controls corner-top-left"></div>


  <script>
    const canvas = document.getElementById('spiral-canvas');
    const ctx = canvas.getContext('2d');
    const paletteSwitcher = document.getElementById('palette-switcher');
    
    // ... (configuração de canvas e variáveis da simulação inalteradas) ...
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // --- Core Simulation Variables ---
    const particles = [];
    const totalParticles = 5000; 
    const baseSpiralScale = 10; 
    let rotation = 0; 
    let tick = 0; 
    
    // --- MODIFIED: Set spiralProgress to 1.0 to start at full size ---
    let spiralProgress = 1.0; 
    const maxSpiralProgress = 1.0; 
    // const spiralGrowthRate = maxSpiralProgress / (60 * 10); // No longer needed

    // --- Interactivity Variables ---
    const mouse = { x: width / 2, y: height / 2, down: false };
    // const shockwaves = []; // REMOVED: Shockwave feature removed
    let currentScaleModifier = 1.0; 
    
    // --- Strategy 3: User-Controlled Evolution (Color Palettes) ---
    const palettes = [
        ['#FF1E8E', '#FFEF00', '#00FFF7', '#B200FF', '#A6FF00'], // Original
        ['#ffbe0b', '#fb5607', '#ff006e', '#8338ec', '#3a86ff'], // Vibrant
        ['#177e89', '#084c61', '#db3a34', '#ffc857', '#323031'], // Muted
        ['#f8f9fa', '#e9ecef', '#dee2e6', '#ced4da', '#adb5bd']  // Grayscale
    ];
    let currentPaletteIndex = 0;

    // --- Particle Initialization (MODIFIED) ---
    // Removed physics properties (vx, vy, offsetX, offsetY)
    // as they are no longer needed for a rigid spiral.
    for (let i = 0; i < totalParticles; i++) {
      const theta = i * 0.1;
      const r = baseSpiralScale * theta;
      particles.push({ 
        baseTheta: theta, 
        r: r,
        x: 0, y: 0, 
      });
    }
    
    // --- ATUALIZADO: createPaletteButtons ---
    function createPaletteButtons() {
        paletteSwitcher.innerHTML = ''; // Limpa botões existentes
        palettes.forEach((palette, index) => {
            const button = document.createElement('button');
            button.classList.add('im-button', 'palette-swatch'); 
            
            if (index === currentPaletteIndex) {
                button.classList.add('active');
            }

            const representativeColor = palette[2]; 
            button.style.backgroundColor = representativeColor;
            button.addEventListener('mousedown', () => {
                document.querySelectorAll('.palette-swatch').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentPaletteIndex = index;
            });
            
            button.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Previne o clique na canvas
                currentPaletteIndex = index;
                
                document.querySelectorAll('.palette-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
            });
            
            paletteSwitcher.appendChild(button);
        });
    }

    // --- Main Animation Loop (MODIFIED) ---
    function animateSpiral() {
      tick++; 
      
      // REMOVED: Spiral growth logic is no longer needed
      // if (spiralProgress < maxSpiralProgress) {
      //   spiralProgress += spiralGrowthRate;
      // }

      // MODIFIED: Use a solid black with lower opacity for a "trails" effect
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Was 0.08, lowered for brighter/longer trails
      ctx.fillRect(0, 0, width, height);
      
      // REMOVED: Pulse and Glow effect for a cleaner look
      // const pulse = 0.05 + 0.02 * Math.sin(tick * 0.02);
      // const glow = ...
      // ctx.fillStyle = glow;
      // ctx.fillRect(0, 0, width, height);

      // REMOVED: Speed zone logic
      // const speedZoneSize = 100;
      // ...
      
      // MODIFIED: Re-added speed zone logic for top corners
      const speedZoneSize = 150; // Matching the UI fade trigger
      let inSpeedZone = false;

      // Check Top-Left
      if (mouse.x < speedZoneSize && mouse.y < speedZoneSize) {
          inSpeedZone = true;
      }
      // Check Top-Right
      else if (mouse.x > width - speedZoneSize && mouse.y < speedZoneSize) {
          inSpeedZone = true;
      }

      const speedMultiplier = inSpeedZone ? 5.0 : 1.0; // Was 1.0, now speeds up in corners
      const defaultSpeed = 0.001; 
      const speed = defaultSpeed * speedMultiplier;
      rotation -= speed;

      // This logic is kept - spiral still scales with mouse Y position
      // MODIFIED: Clamped the zoom range to be less extreme.
      // Was: 0.5 + (mouse.y / height) * 1.5; (Range: 0.5x to 2.0x)
      const targetScaleModifier = 0.75 + (mouse.y / height) * 0.75; // New Range: 0.75x to 1.5x
      currentScaleModifier += (targetScaleModifier - currentScaleModifier) * 0.05; 

      // MODIFIED: Wobble feature removed, set to 0
      const wobble = 0; // 20 * Math.sin(tick * 0.01);
      
      // MODIFIED: visibleCount is now always totalParticles
      const visibleCount = totalParticles; // Math.floor(totalParticles * spiralProgress);
      
      // REMOVED: Shockwave drawing loop
      // for (let i = shockwaves.length - 1; i >= 0; i--) { ... }

      for (let i = 0; i < visibleCount; i++) {
        const p = particles[i];
        
        // MODIFIED: Flex feature removed, set to 0
        const flex = 0; // 0.2 * Math.sin(tick * 0.005 + i * 0.001);
        const angle = p.baseTheta + rotation + flex;
        const scaledR = p.r * currentScaleModifier; 
        
        const baseX = width / 2 + wobble + scaledR * Math.cos(angle);
        const baseY = height / 2 + wobble * 0.5 + scaledR * Math.sin(angle);

        // --- ALL PHYSICS REMOVED ---
        // The mouse repulsion, shockwave interaction, and physics
        // updates (vx, vy, offsetX, offsetY) have been removed
        // to make the spiral rigid.
        // ---------------------------

        // MODIFIED: Set particle position directly to the calculated spiral point
        p.x = baseX;
        p.y = baseY;

        if (p.x < 0 || p.x > width || p.y < 0 || p.y > height) continue;
        
        const colorIndex = Math.floor(i / 500) % palettes[currentPaletteIndex].length;
        ctx.fillStyle = palettes[currentPaletteIndex][colorIndex];
        
        // MODIFIED: Increased base radius to make particles more visible
        const baseRadius = 1.0 + (i / totalParticles) * 1.5; // Was 0.5 + ...
        // REMOVED: Dynamic radius made particles disappear
        // const dynamicRadius = 0.5 * Math.sin(tick * 0.1 + i * 0.01);
        const finalRadius = baseRadius; // + dynamicRadius;

        ctx.beginPath();
        ctx.arc(p.x, p.y, finalRadius, 0, Math.PI * 2);
        ctx.fill();
      }

      requestAnimationFrame(animateSpiral);
    }
    
    // --- Initial Setup Calls ---
    createPaletteButtons();
    animateSpiral();

    // --- Logic to show UI on load and then fade out (Inalterado) ---
    paletteSwitcher.style.opacity = '1';
    setTimeout(() => {
        const cornerThreshold = 150;
        if (!(mouse.x < cornerThreshold && mouse.y < cornerThreshold)) {
            paletteSwitcher.style.opacity = '0';
        }
    }, 5000);

    // --- Event Listeners (Inalterado) ---
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    // Mouse move still controls scale and UI visibility
    window.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;

      const cornerThreshold = 150;
      if (e.clientX < cornerThreshold && e.clientY < cornerThreshold) {
        paletteSwitcher.style.opacity = '1';
      } else {
        paletteSwitcher.style.opacity = '0';
      }
    });

  </script>
</body>
</html>