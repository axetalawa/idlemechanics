<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Título atualizado -->
  <title>Iris [Idle Mechanics]</title>
  
  <!-- ADICIONADO: O novo arquivo de tema unificado -->
  <link rel="stylesheet" href="idle-mechanics-theme.css">
  
  <!-- ADICIONADO: Fonte 'Inter' para consistência -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  
  <style>
    /* REMOVIDO: :root (variáveis não utilizadas)
      REMOVIDO: html, body (agora no tema)
    */
    
    /* Estilo de canvas mantido */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* REMOVIDO: #palette-switcher (agora .im-controls)
      REMOVIDO: .palette-button (agora .im-button.palette-swatch)
      REMOVIDO: .color-swatch (não utilizado)
    */

  </style>
</head>
<body>
  <!-- Canvas da simulação (Inalterado) -->
  <canvas id="spiral-canvas"></canvas>

  <!-- 
    ATUALIZADO: 
    - O contêiner agora usa as classes de "Altar de Controle" do tema.
    - O .corner-top-left o posiciona corretamente.
  -->
  <div id="palette-switcher" class="im-controls corner-top-left"></div>


  <script>
    const canvas = document.getElementById('spiral-canvas');
    const ctx = canvas.getContext('2d');
    const paletteSwitcher = document.getElementById('palette-switcher');
    
    // ... (configuração de canvas e variáveis da simulação inalteradas) ...
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // --- Core Simulation Variables ---
    const particles = [];
    const totalParticles = 5000; 
    const baseSpiralScale = 10; 
    let rotation = 0; 
    let tick = 0; 
    let spiralProgress = 0; 
    const maxSpiralProgress = 1.0; 
    const spiralGrowthRate = maxSpiralProgress / (60 * 10); 

    // --- Interactivity Variables ---
    const mouse = { x: width / 2, y: height / 2, down: false };
    const shockwaves = [];
    let currentScaleModifier = 1.0; 
    
    // --- Strategy 3: User-Controlled Evolution (Color Palettes) ---
    const palettes = [
        ['#FF1E8E', '#FFEF00', '#00FFF7', '#B200FF', '#A6FF00'], // Original
        ['#ffbe0b', '#fb5607', '#ff006e', '#8338ec', '#3a86ff'], // Vibrant
        ['#177e89', '#084c61', '#db3a34', '#ffc857', '#323031'], // Muted
        ['#f8f9fa', '#e9ecef', '#dee2e6', '#ced4da', '#adb5bd']  // Grayscale
    ];
    let currentPaletteIndex = 0;

    // --- Particle Initialization (Inalterado) ---
    for (let i = 0; i < totalParticles; i++) {
      const theta = i * 0.1;
      const r = baseSpiralScale * theta;
      particles.push({ 
        baseTheta: theta, 
        r: r,
        x: 0, y: 0, 
        vx: 0, vy: 0, 
        offsetX: 0, offsetY: 0, 
      });
    }
    
    // --- ATUALIZADO: createPaletteButtons ---
    function createPaletteButtons() {
        paletteSwitcher.innerHTML = ''; // Limpa botões existentes
        palettes.forEach((palette, index) => {
            // ATUALIZADO: Cria um <button> em vez de <div>
            const button = document.createElement('button');
            
            // ATUALIZADO: Adiciona classes do tema
            button.classList.add('im-button', 'palette-swatch'); 
            
            if (index === currentPaletteIndex) {
                button.classList.add('active');
            }

            // ATUALIZADO: Define a cor de fundo E a cor de fundo ativa
            // para sobrescrever o .active cinza padrão.
            const representativeColor = palette[2]; // Pega a cor do meio
            button.style.backgroundColor = representativeColor;
            button.addEventListener('mousedown', () => {
                // Remove .active de todos
                document.querySelectorAll('.palette-swatch').forEach(btn => btn.classList.remove('active'));
                // Adiciona .active a este
                button.classList.add('active');
                currentPaletteIndex = index;
            });
            
            // Corrige o bug de clique (movido de 'click' para 'mousedown')
            button.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Previne o clique na canvas
                currentPaletteIndex = index;
                
                document.querySelectorAll('.palette-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
            });
            
            paletteSwitcher.appendChild(button);
        });
    }

    // --- Main Animation Loop (Inalterado) ---
    function animateSpiral() {
      tick++; 
      
      if (spiralProgress < maxSpiralProgress) {
        spiralProgress += spiralGrowthRate;
      }

      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
      ctx.fillRect(0, 0, width, height);
      
      const pulse = 0.05 + 0.02 * Math.sin(tick * 0.02);
      const glow = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);
      glow.addColorStop(0, `rgba(178, 0, 255, ${pulse * 0.2})`); 
      glow.addColorStop(1, 'rgba(0, 0, 0, 0.0)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, width, height);

      const speedZoneSize = 100;
      let inAnySpeedZone = false;

      const corners = [
          { x: 0, y: 0 }, // Top-Left
          { x: width - speedZoneSize, y: 0 }, // Top-Right
          { x: 0, y: height - speedZoneSize }, // Bottom-Left
          { x: width - speedZoneSize, y: height - speedZoneSize } // Bottom-Right
      ];

      for (const corner of corners) {
          if (mouse.x >= corner.x && mouse.x <= corner.x + speedZoneSize &&
              mouse.y >= corner.y && mouse.y <= corner.y + speedZoneSize) {
              inAnySpeedZone = true;
              break; 
          }
      }
      
      const speedMultiplier = inAnySpeedZone ? 4.0 : 1.0;
      const defaultSpeed = 0.001; 
      const speed = defaultSpeed * speedMultiplier;
      rotation -= speed;

      const targetScaleModifier = 0.5 + (mouse.y / height) * 1.5;
      currentScaleModifier += (targetScaleModifier - currentScaleModifier) * 0.05; 

      const wobble = 20 * Math.sin(tick * 0.01);
      const visibleCount = Math.floor(totalParticles * spiralProgress);
      
      for (let i = shockwaves.length - 1; i >= 0; i--) {
        const sw = shockwaves[i];
        sw.radius += 5; 
        sw.alpha = 1 - sw.radius / sw.maxRadius;

        if (sw.alpha <= 0) {
            shockwaves.splice(i, 1);
        } else {
            ctx.beginPath();
            ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${sw.alpha * 0.5})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
      }

      for (let i = 0; i < visibleCount; i++) {
        const p = particles[i];
        
        const flex = 0.2 * Math.sin(tick * 0.005 + i * 0.001);
        const angle = p.baseTheta + rotation + flex;
        const scaledR = p.r * currentScaleModifier; 
        
        const baseX = width / 2 + wobble + scaledR * Math.cos(angle);
        const baseY = height / 2 + wobble * 0.5 + scaledR * Math.sin(angle);

        const dx = baseX + p.offsetX - mouse.x;
        const dy = baseY + p.offsetY - mouse.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const maxDist = 75;
        
        let force = 0;
        if (distance < maxDist) {
            force = (1 - distance / maxDist) * 10;
        }

        p.vx += (force * dx / distance) || 0;
        p.vy += (force * dy / distance) || 0;
        
         for (const sw of shockwaves) {
            const pdx = p.x - sw.x;
            const pdy = p.y - sw.y;
            const pDist = Math.sqrt(pdx*pdx + pdy*pdy);
            const rippleWidth = 20;
            if (Math.abs(pDist - sw.radius) < rippleWidth) {
                const shockwaveForce = (1 - Math.abs(pDist - sw.radius) / rippleWidth) * 2;
                p.vx += shockwaveForce * pdx / pDist || 0;
                p.vy += shockwaveForce * pdy / pDist || 0;
            }
        }

        p.vx *= 0.9;
        p.vy *= 0.9;
        p.offsetX += p.vx;
        p.offsetY += p.vy;
        p.offsetX += (0 - p.offsetX) * 0.1;
        p.offsetY += (0 - p.offsetY) * 0.1;

        p.x = baseX + p.offsetX;
        p.y = baseY + p.offsetY;

        if (p.x < 0 || p.x > width || p.y < 0 || p.y > height) continue;
        
        const colorIndex = Math.floor(i / 500) % palettes[currentPaletteIndex].length;
        ctx.fillStyle = palettes[currentPaletteIndex][colorIndex];
        
        const baseRadius = 0.5 + (i / totalParticles) * 1.5;
        const dynamicRadius = 0.5 * Math.sin(tick * 0.1 + i * 0.01);
        const finalRadius = baseRadius + dynamicRadius;

        ctx.beginPath();
        ctx.arc(p.x, p.y, finalRadius, 0, Math.PI * 2);
        ctx.fill();
      }

      requestAnimationFrame(animateSpiral);
    }
    
    // --- Initial Setup Calls ---
    createPaletteButtons();
    animateSpiral();

    // --- Logic to show UI on load and then fade out (Inalterado) ---
    paletteSwitcher.style.opacity = '1';
    setTimeout(() => {
        const cornerThreshold = 150;
        if (!(mouse.x < cornerThreshold && mouse.y < cornerThreshold)) {
            paletteSwitcher.style.opacity = '0';
        }
    }, 5000);

    // --- Event Listeners (Inalterado) ---
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    window.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;

      const cornerThreshold = 150;
      if (e.clientX < cornerThreshold && e.clientY < cornerThreshold) {
        paletteSwitcher.style.opacity = '1';
      } else {
        paletteSwitcher.style.opacity = '0';
      }
    });
    
    canvas.addEventListener('click', e => {
      shockwaves.push({
          x: e.clientX,
          y: e.clientY,
          radius: 0,
          maxRadius: Math.max(width, height) * 0.5,
          alpha: 1
      });
    });

  </script>
</body>
</html>
