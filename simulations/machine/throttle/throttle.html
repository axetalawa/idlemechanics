<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isolated Spiral Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Root Variables from original file */
        :root {
            --dark-bg: #0D0D0D;
            --light-text: #BBBBBB;
            --accent-text-color: #666666;
            --primary-pink: #FF007F; /* Electric Placenta Hot Pink */
            --electric-cyan: #00FFF7; /* Electric Cyan */
            --solar-yellow: #FFEF00; /* Electric Solar Yellow */
            --lime-acid-green: #A6FF00; /* Electric Lime Green */
            --purple-accent: #4A006F; /* Dark Mystical Purple */
            --ritual-orange: #FF5E00; /* Electric Blood Orange of Dawn */
        }
        
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Black background for the sim */
            color: var(--light-text);
            overflow: hidden; /* Prevent scrolling */
            min-height: 100vh;
        }

        /* --- DNA Simulation Specific Styles --- */
        #dna-section {
            height: 100vh;
            width: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #dna-sim-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .controls-top { 
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            gap: 15px; 
            max-width: 90%; 
            white-space: nowrap; 
            /* Added for smooth transition when showing/hiding */
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .controls-top button.pink-orb {
            background-color: var(--primary-pink); 
            border: none;
            width: 60px; 
            height: 60px; 
            cursor: pointer;
            border-radius: 50%; 
            box-shadow: 0 0 15px 5px var(--primary-pink), 
                        0 0 30px 10px rgba(255, 0, 127, 0.5); 
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            text-decoration: none; 
            padding: 0; 
        }
        .controls-top button.pink-orb:hover {
            background-color: #e00071; 
            transform: translateY(-2px);
            box-shadow: 0 0 20px 8px var(--primary-pink), 
                        0 0 40px 15px rgba(255, 0, 127, 0.7); 
        }
        .controls-top button.pink-orb:active {
            background-color: #c70065; 
            transform: translateY(0);
            box-shadow: 0 0 10px 3px var(--primary-pink), 
                        0 0 20px 7px rgba(255, 0, 127, 0.4); 
        }

        .controls-top button.green-orb {
            background-color: var(--lime-acid-green);
            border: none;
            width: 60px; 
            height: 60px; 
            cursor: pointer;
            border-radius: 50%; 
            box-shadow: 0 0 15px 5px var(--lime-acid-green), 
                        0 0 30px 10px rgba(166, 255, 0, 0.5); 
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            text-decoration: none; 
            padding: 0; 
        }
        .controls-top button.green-orb:hover {
            background-color: #8acc00; 
            transform: translateY(-2px);
            box-shadow: 0 0 20px 8px var(--lime-acid-green), 
                        0 0 40px 15px rgba(166, 255, 0, 0.7); 
        }
        .controls-top button.green-orb:active {
            background-color: #739900; 
            transform: translateY(0);
            box-shadow: 0 0 10px 3px var(--lime-acid-green), 
                        0 0 20px 7px rgba(166, 255, 0, 0.4); 
        }

        .controls-top button.orange-orb {
            background-color: var(--ritual-orange); 
            border: none;
            width: 60px; 
            height: 60px; 
            cursor: pointer;
            border-radius: 50%; 
            box-shadow: 0 0 15px 5px var(--ritual-orange), 
                        0 0 30px 10px rgba(255, 94, 0, 0.5); 
            transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            text-decoration: none; 
            padding: 0; 
        }
        .controls-top button.orange-orb:hover {
            background-color: #e65600; 
            transform: translateY(-2px);
            box-shadow: 0 0 20px 8px var(--ritual-orange), 
                        0 0 40px 15px rgba(255, 94, 0, 0.7); 
        }
        .controls-top button.orange-orb:active {
            background-color: #cc4d00; 
            transform: translateY(0);
            box-shadow: 0 0 10px 3px var(--ritual-orange), 
                        0 0 20px 7px rgba(255, 94, 0, 0.4); 
        }

        .controls-bottom { 
            position: absolute;
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            z-index: 10;
            display: flex; 
            flex-direction: row; 
            align-items: center; 
            justify-content: center; 
            gap: 15px; 
            max-width: 90%; 
            /* Added for smooth transition when showing/hiding */
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        /* New class to hide controls */
        .controls-hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none; /* Prevents interaction when hidden */
        }

        .slider-wrapper {
            width: 100px; 
            height: 8px; 
            position: relative; 
            transform: rotate(-90deg); 
            transform-origin: center center; 
            margin: 0; 
            flex-shrink: 0; 
            overflow: visible; 
        }

        @keyframes breathing-track {
            0% { background-color: #1a1a1a; } 
            50% { background-color: #000000; } 
            100% { background-color: #1a1a1a; }
        }

        input[type="range"] {
            -webkit-appearance: none; 
            appearance: none;
            width: 100%; 
            height: 8px; 
            background: #1a1a1a; 
            outline: none;
            border-radius: 4px; 
            opacity: 0.7;
            transition: opacity .2s;
            cursor: pointer;
            margin: 0; 
            animation: breathing-track 4s infinite alternate; 
        }
        input[type="range"]::-webkit-slider-runnable-track {
            border-radius: 4px; 
            transition: none; 
        }
        input[type="range"]::-moz-range-track {
            border-radius: 4px;
            transition: none; 
        }
        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px; 
            height: 20px; 
            border-radius: 50%; 
            background: var(--electric-cyan); 
            cursor: pointer;
            box-shadow: 0 0 5px 2px rgba(0, 255, 247, 0.5); 
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--electric-cyan); 
            cursor: pointer;
            box-shadow: 0 0 5px 2px rgba(0, 255, 247, 0.5);
        }
    </style>
</head>
<body>
    <div id="dna-section">
        <canvas id="dna-sim-canvas"></canvas>
        <!-- Added controls-hidden class to initially hide buttons -->
        <div class="controls-top controls-hidden">
            <button id="phaseToggleButton" class="green-orb" title="Toggle Animation Phase"></button>
            <button id="tunnelButton" class="pink-orb" title="Restart Tunneling"></button>
            <button id="exitDNASimButton" class="orange-orb" title="Exit Simulation"></button>
        </div>
        <!-- Added controls-hidden class to initially hide buttons -->
        <div class="controls-bottom controls-hidden">
            <div class="slider-wrapper">
                <input type="range" id="speedSlider" min="0" max="100" value="50" title="Adjust Animation Speed">
            </div>
            <div class="slider-wrapper">
                <input type="range" id="radiusSlider" min="10" max="80" value="30" title="Adjust Helix Radius">
            </div>
            <div class="slider-wrapper">
                <input type="range" id="turnsSlider" min="5" max="50" value="25" title="Adjust Helix Turns">
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- SCENE SETUP ---
            let scene, camera, renderer, coreHelix;
            let verticalDistanceOfHelix; 
            let orbs = []; 
            
            // Orb properties
            const NUM_ORBS = 7; 
            const ORB_RADIUS = 4;
            const ORB_OSCILLATION_RANGE = 40; 
            const ORB_OSCILLATION_SPEED_BASE = 0.0005; 

            // --- INTERACTION VARIABLES ---
            let isMouseDown = false;
            let previousMousePosition = { x: 0, y: 0 };
            let isTunneling = false;
            const BASE_TUNNELING_SPEED = 0.8; 
            let initialTunnelComplete = false; // New flag for initial tunnel completion

            // --- ANIMATION PHASES FOR IDLE STATE ---
            const animationPhases = [
                { id: 1, rotationSpeedY: 0.002, rotationSpeedX: 0.0004, duration: 8000 }, 
                { id: 2, rotationSpeedY: -0.003, rotationSpeedX: 0.0002, duration: 8000 }, 
                { id: 3, rotationSpeedY: 0.001, rotationSpeedX: -0.0005, duration: 8000 }, 
                { id: 4, rotationSpeedY: 0.004, rotationSpeedX: 0, duration: 8000 },     
                { id: 5, rotationSpeedY: 0, rotationSpeedX: 0.0006, duration: 8000 },     
                { id: 6, rotationSpeedY: -0.002, rotationSpeedX: -0.0004, duration: 8000 },
                { id: 7, rotationSpeedY: 0.003, rotationSpeedX: -0.0002, duration: 8000 }, 
                { id: 8, rotationSpeedY: -0.001, rotationSpeedX: 0.0005, duration: 8000 }, 
                { id: 9, rotationSpeedY: -0.004, rotationSpeedX: 0, duration: 8000 },    
                { id: 10, rotationSpeedY: 0, rotationSpeedX: -0.0006, duration: 8000 }    
            ];
            let currentPhaseIndex = 0;
            let phaseTimer = 0;
            let lastFrameTime = 0; 

            const MIN_SPEED_MULTIPLIER = 0.5; 
            const MAX_SPEED_MULTIPLIER = 1.5; 
            let currentSpeedMultiplier = 1.0; 

            let currentHelixRadius = 30; 
            let currentHelixTurns = 25;  

            // DOM elements
            let tunnelButtonElement, phaseToggleButtonElement, speedSliderElement, radiusSliderElement, turnsSliderElement, exitDNASimButtonElement; 
            let controlsTopElement, controlsBottomElement; // New variables for control divs
            
            function initDNASimulation() { 
                const dnaSimCanvas = document.getElementById('dna-sim-canvas'); 
                tunnelButtonElement = document.getElementById('tunnelButton');
                phaseToggleButtonElement = document.getElementById('phaseToggleButton');
                exitDNASimButtonElement = document.getElementById('exitDNASimButton'); 
                speedSliderElement = document.getElementById('speedSlider'); 
                radiusSliderElement = document.getElementById('radiusSlider'); 
                turnsSliderElement = document.getElementById('turnsSlider');    

                // Get references to control divs
                controlsTopElement = document.querySelector('.controls-top');
                controlsBottomElement = document.querySelector('.controls-bottom');

                speedSliderElement.value = 50; 
                radiusSliderElement.value = 45; 
                turnsSliderElement.value = 28;  

                currentSpeedMultiplier = MIN_SPEED_MULTIPLIER + 
                                         (speedSliderElement.value / 100) * (MAX_SPEED_MULTIPLIER - MIN_SPEED_MULTIPLIER);
                currentHelixRadius = parseInt(radiusSliderElement.value); 
                currentHelixTurns = parseInt(turnsSliderElement.value);    

                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x000000, 300, 800); 

                camera = new THREE.PerspectiveCamera(75, dnaSimCanvas.clientWidth / dnaSimCanvas.clientHeight, 0.1, 2000); 
                camera.position.set(0, 0, 250); 
                camera.lookAt(0, 0, 0); 

                renderer = new THREE.WebGLRenderer({ canvas: dnaSimCanvas, antialias: true }); 
                renderer.setSize(dnaSimCanvas.clientWidth, dnaSimCanvas.clientHeight); 
                renderer.setPixelRatio(window.devicePixelRatio); 

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2); 
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                verticalDistanceOfHelix = (120 / 4) * currentHelixTurns * 1.0; 
                coreHelix = createHelix(1.0, currentHelixRadius, currentHelixTurns); 
                scene.add(coreHelix);

                const orbGeometry = new THREE.SphereGeometry(ORB_RADIUS, 16, 16); 
                // Using var(--electric-cyan) for orb base color
                const orbBaseColor = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--electric-cyan')); 

                for (let i = 0; i < NUM_ORBS; i++) {
                    const orbMaterial = new THREE.MeshBasicMaterial({ 
                        color: orbBaseColor, 
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending 
                    });
                    const orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);
                    
                    const orbLight = new THREE.PointLight(orbBaseColor, 3, 150); 
                    
                    const baseY = (i / (NUM_ORBS - 1)) * verticalDistanceOfHelix - (verticalDistanceOfHelix / 2);
                    orbMesh.position.set(0, baseY, 0); 
                    orbLight.position.copy(orbMesh.position);

                    scene.add(orbMesh);
                    scene.add(orbLight);

                    orbs.push({ mesh: orbMesh, light: orbLight, baseY: baseY, oscillationOffset: Math.random() * Math.PI * 2 });
                }
                
                startTunneling();
                addEventListenersDNASim(); 
            }

            function createHelix(scale, helixRadius, helixTurns) {
                const helix = new THREE.Group(); 
                const radius = helixRadius * scale; 
                const tubeRadius = 3 * scale; 
                const turns = helixTurns; 
                const pointsPerTurn = 16; 
                const calculatedVerticalDistance = (120 / 4) * turns * scale; 
                const totalPoints = pointsPerTurn * turns; 
                
                // Using CSS variables for colors
                const ultravioletViolet = getComputedStyle(document.documentElement).getPropertyValue('--purple-accent'); 
                const solarYellow = getComputedStyle(document.documentElement).getPropertyValue('--solar-yellow');         
                
                const sphereGeometry = new THREE.SphereGeometry(tubeRadius, 8, 8); 
                const material1 = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(ultravioletViolet), 
                    emissive: new THREE.Color(ultravioletViolet), 
                    emissiveIntensity: 0.9 
                });
                const material2 = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(solarYellow), 
                    emissive: new THREE.Color(solarYellow), 
                    emissiveIntensity: 0.9 
                });
                const rungMaterial = new THREE.LineBasicMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.4 });
                for (let i = 0; i <= totalPoints; i++) {
                    const y = (i / totalPoints) * calculatedVerticalDistance - (calculatedVerticalDistance / 2);
                    const angle = (i / pointsPerTurn) * Math.PI * 2;
                    const sphere1 = new THREE.Mesh(sphereGeometry, material1);
                    sphere1.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                    helix.add(sphere1);
                    const sphere2 = new THREE.Mesh(sphereGeometry, material2);
                    sphere2.position.set(Math.cos(angle + Math.PI) * radius, y, Math.sin(angle + Math.PI) * radius);
                    helix.add(sphere2);
                    const points = [sphere1.position.clone(), sphere2.position.clone()];
                    const rungGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const rung = new THREE.Line(rungGeometry, rungMaterial);
                    helix.add(rung);
                }
                return helix;
            }

            function animateDNASim() { 
                requestAnimationFrame(animateDNASim);
                if (!lastFrameTime) lastFrameTime = performance.now(); 
                const deltaTime = performance.now() - lastFrameTime; 
                lastFrameTime = performance.now();
                orbs.forEach(orbData => {
                    const pulsation = Math.sin(performance.now() * 0.002 + orbData.oscillationOffset) * 0.2 + 0.8;
                    orbData.light.intensity = 3 * pulsation;
                    orbData.mesh.material.opacity = 0.8 * pulsation;
                    orbData.mesh.scale.setScalar(1 + (1-pulsation) * 0.1); 
                    const hue = (performance.now() * 0.00005 + orbData.oscillationOffset / (Math.PI * 2) * 0.5) % 1; 
                    orbData.light.color.setHSL(hue, 1, 0.5); 
                    orbData.mesh.material.color.setHSL(hue, 1, 0.5);
                    orbData.mesh.position.y = orbData.baseY + Math.sin(performance.now() * ORB_OSCILLATION_SPEED_BASE + orbData.oscillationOffset) * ORB_OSCILLATION_RANGE;
                    orbData.light.position.copy(orbData.mesh.position);
                });
                if (isTunneling) {
                    camera.position.y += BASE_TUNNELING_SPEED * currentSpeedMultiplier;
                    if (camera.position.y > verticalDistanceOfHelix / 2 + 50) { 
                        isTunneling = false; 
                        initialTunnelComplete = true; // Set flag when initial tunnel completes
                        camera.position.y = 0; 
                        camera.position.z = 250; 
                        coreHelix.rotation.set(0, 0, 0); 
                        // Show controls after initial tunnel
                        if (controlsTopElement) controlsTopElement.classList.remove('controls-hidden');
                        if (controlsBottomElement) controlsBottomElement.classList.remove('controls-hidden');
                    }
                    camera.lookAt(new THREE.Vector3(0, camera.position.y + 100, 0)); 
                } else {
                    if (!isMouseDown) { 
                        const currentPhase = animationPhases[currentPhaseIndex];
                        coreHelix.rotation.y += currentPhase.rotationSpeedY * currentSpeedMultiplier * (deltaTime / 16.6667); 
                        coreHelix.rotation.x += currentPhase.rotationSpeedX * currentSpeedMultiplier * (deltaTime / 16.6667);
                        phaseTimer += deltaTime;
                        if (phaseTimer >= currentPhase.duration) {
                            currentPhaseIndex = (currentPhaseIndex + 1) % animationPhases.length;
                            phaseTimer = 0;
                        }
                    }
                }
                renderer.render(scene, camera); 
            }

            function addEventListenersDNASim() { 
                const dnaSimCanvas = document.getElementById('dna-sim-canvas');
                window.addEventListener('resize', onWindowResizeDNASim, false); 
                dnaSimCanvas.addEventListener('mousedown', onMouseDown, false); 
                dnaSimCanvas.addEventListener('mousemove', onMouseMove, false); 
                window.addEventListener('mouseup', onMouseUp, false); 
                dnaSimCanvas.addEventListener('wheel', onMouseWheel, { passive: false }); 
                tunnelButtonElement.addEventListener('click', startTunneling); 
                phaseToggleButtonElement.addEventListener('click', toggleAnimationPhase); 
                speedSliderElement.addEventListener('input', updateSpeedMultiplier); 
                radiusSliderElement.addEventListener('input', updateHelixParameters); 
                turnsSliderElement.addEventListener('input', updateHelixParameters);    
                exitDNASimButtonElement.addEventListener('click', () => {
                    // This button won't do anything in the isolated doc, 
                    // but we keep the listener to avoid errors.
                    console.log("Exit button clicked.");
                }); 
            }

            function onWindowResizeDNASim() { 
                const dnaSimCanvas = document.getElementById('dna-sim-canvas');
                if (dnaSimCanvas) {
                    camera.aspect = dnaSimCanvas.clientWidth / dnaSimCanvas.clientHeight;
                    camera.updateProjectionMatrix(); 
                    renderer.setSize(dnaSimCanvas.clientWidth, dnaSimCanvas.clientHeight); 
                }
            }

            function onMouseDown(event) {
                if (isTunneling) return; 
                isMouseDown = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }

            function onMouseMove(event) {
                if (!isMouseDown || isTunneling) return; 
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                coreHelix.rotation.y += deltaX * 0.005;
                coreHelix.rotation.x += deltaY * 0.005;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }

            function onMouseUp() {
                if (isTunneling) return; 
                isMouseDown = false;
            }
            
            function onMouseWheel(event) {
                if (isTunneling) return; 
                event.preventDefault(); 
                camera.position.z -= event.deltaY * 0.1; 
            }

            function startTunneling() {
                isTunneling = true; 
                // Hide controls if tunneling is restarted, unless it's the very first time
                if (initialTunnelComplete) {
                     if (controlsTopElement) controlsTopElement.classList.add('controls-hidden');
                     if (controlsBottomElement) controlsBottomElement.classList.add('controls-hidden');
                }
                camera.position.y = -verticalDistanceOfHelix / 2 + 10; 
                camera.position.z = 5; 
                coreHelix.rotation.set(0, 0, 0); 
                currentPhaseIndex = 0;
                phaseTimer = 0;
            }

            function toggleAnimationPhase() {
                if (isTunneling) return; 
                currentPhaseIndex = (currentPhaseIndex + 1) % animationPhases.length;
                phaseTimer = 0; 
            }

            function updateSpeedMultiplier(event) {
                const sliderValue = parseInt(event.target.value); 
                currentSpeedMultiplier = MIN_SPEED_MULTIPLIER + 
                                         (sliderValue / 100) * (MAX_SPEED_MULTIPLIER - MIN_SPEED_MULTIPLIER);
            }

            function updateHelixParameters() {
                currentHelixRadius = parseInt(radiusSliderElement.value);
                currentHelixTurns = parseInt(turnsSliderElement.value);
                if (coreHelix) { 
                    scene.remove(coreHelix);
                }
                verticalDistanceOfHelix = (120 / 4) * currentHelixTurns * 1.0; 
                coreHelix = createHelix(1.0, currentHelixRadius, currentHelixTurns);
                scene.add(coreHelix);
                orbs.forEach((orbData, i) => {
                    const newBaseY = (i / (NUM_ORBS - 1)) * verticalDistanceOfHelix - (verticalDistanceOfHelix / 2);
                    orbData.baseY = newBaseY;
                    orbData.mesh.position.y = newBaseY + Math.sin(performance.now() * ORB_OSCILLATION_SPEED_BASE + orbData.oscillationOffset) * ORB_OSCILLATION_RANGE;
                    orbData.light.position.copy(orbData.mesh.position);
                });
            }

            // --- SCRIPT EXECUTION ---
            initDNASimulation();
            animateDNASim();
        });
    </script>
</body>
</html>
