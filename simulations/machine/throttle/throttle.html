<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throttle [Idle Mechanics]</title>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <!-- REMOVIDO: Link para o arquivo de tema externo -->
    <!-- <link rel="stylesheet" href="idle-mechanics-theme.css"> -->

    <style>
        /* ===========================================
         * ESTILOS COMPLETOS EMBUTIDOS (Baseado no tema)
         * =========================================== */

        /* 1. Variáveis e Base */
        :root {
          --im-color-primary: #ff0090;
          --im-color-secondary: #fff204;
          --im-color-tertiary: #09ff00;
          --im-color-bg: #0D0D0D;
          --im-color-text: #BBBBBB;
          --im-color-ui-bg: rgba(20, 20, 20, 0.7);
        }

        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--im-color-bg);
            color: var(--im-color-text);
            overflow: hidden;
            min-height: 100vh;
        }

         html, body {
           height: 100%;
           width: 100%;
        }


        /* --- Estilos de layout da simulação (Mantidos) --- */
        #dna-section {
            height: 100%; /* Change vh to % for proper fullscreen scaling */
            width: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #dna-sim-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 2. Controles */

        /* Contêiner de Controles */
        .im-controls {
          position: absolute;
          z-index: 100; /* Garante que esteja acima do canvas */
          background-color: var(--im-color-ui-bg);
          border: 1px solid var(--im-color-tertiary);
          border-radius: 8px;
          padding: 15px;
          display: flex;
          gap: 15px;
          backdrop-filter: blur(5px);
          -webkit-backdrop-filter: blur(5px);
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
          /* Força a visibilidade inicial */
          opacity: 1 !important;
          visibility: visible !important;
        }

        /* IDs para posicionamento customizado */
        #controls-top-container {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row; /* Botões lado a lado */
            transition: opacity 0.5s ease, visibility 0.5s ease; /* Mantém transição */
        }

        #controls-bottom-container {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row; /* Sliders lado a lado */
            transition: opacity 0.5s ease, visibility 0.5s ease; /* Mantém transição */
        }

        /* Botão */
         .im-button {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 44px;
          height: 44px;
          border-radius: 50%;
          padding: 0;
          background-color: transparent;
          border: 2px solid var(--im-color-primary);
          color: var(--im-color-primary);
          cursor: pointer;
          transition: all 0.2s ease;
          z-index: 101; /* Acima do contêiner se necessário */
        }
        .im-button:hover {
          color: var(--im-color-text);
          border-color: var(--im-color-secondary);
          box-shadow: 0 0 12px 2px var(--im-color-primary);
          transform: scale(1.05);
        }
        .im-button.active { /* Para uso futuro se necessário */
          background-color: rgba(187, 187, 187, 0.2);
          box-shadow: 0 0 12px 2px var(--im-color-text);
          border-color: var(--im-color-text);
          color: var(--im-color-text);
        }

        /* Sliders (Mesmos estilos embutidos de suction.html) */
        .im-controls input[type="range"] {
          -webkit-appearance: none;
          appearance: none;
          background: transparent;
          cursor: pointer;
          width: 75px;
          margin: 0;
          display: inline-block !important;
          visibility: visible !important;
        }
        .im-controls input[type="range"]::-webkit-slider-runnable-track {
          background: rgba(187, 187, 187, 0.5);
          height: 4px;
          border-radius: 2px;
        }
        .im-controls input[type="range"]::-moz-range-track {
           background: rgba(187, 187, 187, 0.5);
          height: 4px;
          border-radius: 2px;
        }
        .im-controls input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          margin-top: -8px;
          background-color: var(--im-color-text);
          border: 2px solid var(--im-color-bg);
          height: 20px;
          width: 12px;
          border-radius: 3px;
          box-shadow: 0 0 5px 0 rgba(187, 187, 187, 0.5);
          transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.1s ease;
        }
        .im-controls input[type="range"]::-moz-range-thumb {
          background-color: var(--im-color-text);
          border: 2px solid var(--im-color-bg);
          height: 20px;
          width: 12px;
          border-radius: 3px;
          box-shadow: 0 0 5px 0 rgba(187, 187, 187, 0.5);
          transition: transform 0.1s ease, box-shadow 0.1s ease, background-color 0.1s ease;
        }
        .im-controls input[type="range"]:hover::-webkit-slider-thumb {
          transform: scale(1.1);
          background-color: var(--im-color-secondary);
          box-shadow: 0 0 8px 0 var(--im-color-secondary);
        }
        .im-controls input[type="range"]:hover::-moz-range-thumb {
          transform: scale(1.1);
           background-color: var(--im-color-secondary);
          box-shadow: 0 0 8px 0 var(--im-color-secondary);
        }

        /* Classe de funcionalidade para esconder/mostrar controles (Mantida) */
        .controls-hidden {
            opacity: 0 !important; /* Usa !important para garantir */
            visibility: hidden !important; /* Usa !important para garantir */
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="dna-section">
        <canvas id="dna-sim-canvas"></canvas>

        <!-- UI (HTML inalterado, mas agora estilizado por CSS embutido) -->
        <div id="controls-top-container" class="im-controls controls-hidden">
            <button id="phaseToggleButton" class="im-button" title="Toggle Animation Phase"></button>
            <button id="tunnelButton" class="im-button" title="Restart Tunneling"></button>
            <button id="exitDNASimButton" class="im-button" title="Exit Simulation"></button>
        </div>

        <div id="controls-bottom-container" class="im-controls controls-hidden">
            <input type="range" id="speedSlider" min="0" max="100" value="50" title="Adjust Animation Speed">
            <input type="range" id="radiusSlider" min="10" max="80" value="30" title="Adjust Helix Radius">
            <input type="range" id="turnsSlider" min="5" max="50" value="25" title="Adjust Helix Turns">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let scene, camera, renderer, coreHelix;
            let verticalDistanceOfHelix;
            let orbs = [];
            let tunnelButtonElement, phaseToggleButtonElement, speedSliderElement, radiusSliderElement, turnsSliderElement, exitDNASimButtonElement;
            let controlsTopElement, controlsBottomElement;
            const dnaSimCanvas = document.getElementById('dna-sim-canvas'); // Get canvas element early

            function initDNASimulation() {
                // Canvas já obtido acima
                tunnelButtonElement = document.getElementById('tunnelButton');
                phaseToggleButtonElement = document.getElementById('phaseToggleButton');
                exitDNASimButtonElement = document.getElementById('exitDNASimButton');
                speedSliderElement = document.getElementById('speedSlider');
                radiusSliderElement = document.getElementById('radiusSlider');
                turnsSliderElement = document.getElementById('turnsSlider');
                controlsTopElement = document.getElementById('controls-top-container');
                controlsBottomElement = document.getElementById('controls-bottom-container');

                speedSliderElement.value = 50;
                radiusSliderElement.value = 45;
                turnsSliderElement.value = 28;

                currentSpeedMultiplier = MIN_SPEED_MULTIPLIER + (speedSliderElement.value / 100) * (MAX_SPEED_MULTIPLIER - MIN_SPEED_MULTIPLIER);
                currentHelixRadius = parseInt(radiusSliderElement.value);
                currentHelixTurns = parseInt(turnsSliderElement.value);

                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x000000, 300, 800);
                // Use container dimensions directly for aspect ratio
                camera = new THREE.PerspectiveCamera(75, dnaSimCanvas.parentElement.clientWidth / dnaSimCanvas.parentElement.clientHeight, 0.1, 2000);
                camera.position.set(0, 0, 250);
                camera.lookAt(0, 0, 0);
                renderer = new THREE.WebGLRenderer({ canvas: dnaSimCanvas, antialias: true });
                // Set initial size based on parent container
                renderer.setSize(dnaSimCanvas.parentElement.clientWidth, dnaSimCanvas.parentElement.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2); directionalLight.position.set(1, 1, 1); scene.add(directionalLight);

                // Definindo cores diretamente no JS
                const ultravioletViolet = "#4A006F";
                const solarYellow = "#FFEF00";
                const electricCyan = "#00FFF7";

                verticalDistanceOfHelix = (120 / 4) * currentHelixTurns * 1.0;
                coreHelix = createHelix(1.0, currentHelixRadius, currentHelixTurns, ultravioletViolet, solarYellow); scene.add(coreHelix);
                const orbGeometry = new THREE.SphereGeometry(ORB_RADIUS, 16, 16);
                const orbBaseColor = new THREE.Color(electricCyan);
                for (let i = 0; i < NUM_ORBS; i++) {
                    const orbMaterial = new THREE.MeshBasicMaterial({ color: orbBaseColor, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
                    const orbMesh = new THREE.Mesh(orbGeometry, orbMaterial);
                    const orbLight = new THREE.PointLight(orbBaseColor, 3, 150);
                    const baseY = (i / (NUM_ORBS - 1)) * verticalDistanceOfHelix - (verticalDistanceOfHelix / 2);
                    orbMesh.position.set(0, baseY, 0); orbLight.position.copy(orbMesh.position);
                    scene.add(orbMesh); scene.add(orbLight);
                    orbs.push({ mesh: orbMesh, light: orbLight, baseY: baseY, oscillationOffset: Math.random() * Math.PI * 2 });
                }
                startTunneling(); addEventListenersDNASim();
            }

            function createHelix(scale, helixRadius, helixTurns, color1, color2) {
                const helix = new THREE.Group();
                const radius = helixRadius * scale; const tubeRadius = 3 * scale; const turns = helixTurns; const pointsPerTurn = 16; const calculatedVerticalDistance = (120 / 4) * turns * scale; const totalPoints = pointsPerTurn * turns;
                const sphereGeometry = new THREE.SphereGeometry(tubeRadius, 8, 8);
                const material1 = new THREE.MeshPhongMaterial({ color: new THREE.Color(color1), emissive: new THREE.Color(color1), emissiveIntensity: 0.9 });
                const material2 = new THREE.MeshPhongMaterial({ color: new THREE.Color(color2), emissive: new THREE.Color(color2), emissiveIntensity: 0.9 });
                const rungMaterial = new THREE.LineBasicMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.4 });
                for (let i = 0; i <= totalPoints; i++) {
                    const y = (i / totalPoints) * calculatedVerticalDistance - (calculatedVerticalDistance / 2); const angle = (i / pointsPerTurn) * Math.PI * 2;
                    const sphere1 = new THREE.Mesh(sphereGeometry, material1); sphere1.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius); helix.add(sphere1);
                    const sphere2 = new THREE.Mesh(sphereGeometry, material2); sphere2.position.set(Math.cos(angle + Math.PI) * radius, y, Math.sin(angle + Math.PI) * radius); helix.add(sphere2);
                    const points = [sphere1.position.clone(), sphere2.position.clone()]; const rungGeometry = new THREE.BufferGeometry().setFromPoints(points); const rung = new THREE.Line(rungGeometry, rungMaterial); helix.add(rung);
                } return helix;
            }

            const animationPhases = [ { id: 1, rotationSpeedY: 0.002, rotationSpeedX: 0.0004, duration: 8000 }, { id: 2, rotationSpeedY: -0.003, rotationSpeedX: 0.0002, duration: 8000 }, { id: 3, rotationSpeedY: 0.001, rotationSpeedX: -0.0005, duration: 8000 }, { id: 4, rotationSpeedY: 0.004, rotationSpeedX: 0, duration: 8000 }, { id: 5, rotationSpeedY: 0, rotationSpeedX: 0.0006, duration: 8000 }, { id: 6, rotationSpeedY: -0.002, rotationSpeedX: -0.0004, duration: 8000 }, { id: 7, rotationSpeedY: 0.003, rotationSpeedX: -0.0002, duration: 8000 }, { id: 8, rotationSpeedY: -0.001, rotationSpeedX: 0.0005, duration: 8000 }, { id: 9, rotationSpeedY: -0.004, rotationSpeedX: 0, duration: 8000 }, { id: 10, rotationSpeedY: 0, rotationSpeedX: -0.0006, duration: 8000 } ];
            let currentPhaseIndex = 0; let phaseTimer = 0; let lastFrameTime = 0;
            const MIN_SPEED_MULTIPLIER = 0.5; const MAX_SPEED_MULTIPLIER = 1.5; let currentSpeedMultiplier = 1.0;
            let currentHelixRadius = 30; let currentHelixTurns = 25;
            let isMouseDown = false; let previousMousePosition = { x: 0, y: 0 }; let isTunneling = false; const BASE_TUNNELING_SPEED = 0.8; let initialTunnelComplete = false;
            const NUM_ORBS = 7; const ORB_RADIUS = 4; const ORB_OSCILLATION_RANGE = 40; const ORB_OSCILLATION_SPEED_BASE = 0.0005;

            function animateDNASim() {
                requestAnimationFrame(animateDNASim);
                if (!lastFrameTime) lastFrameTime = performance.now(); const deltaTime = performance.now() - lastFrameTime; lastFrameTime = performance.now();
                orbs.forEach(orbData => {
                    const pulsation = Math.sin(performance.now() * 0.002 + orbData.oscillationOffset) * 0.2 + 0.8; orbData.light.intensity = 3 * pulsation; orbData.mesh.material.opacity = 0.8 * pulsation; orbData.mesh.scale.setScalar(1 + (1-pulsation) * 0.1); const hue = (performance.now() * 0.00005 + orbData.oscillationOffset / (Math.PI * 2) * 0.5) % 1; orbData.light.color.setHSL(hue, 1, 0.5); orbData.mesh.material.color.setHSL(hue, 1, 0.5); orbData.mesh.position.y = orbData.baseY + Math.sin(performance.now() * ORB_OSCILLATION_SPEED_BASE + orbData.oscillationOffset) * ORB_OSCILLATION_RANGE; orbData.light.position.copy(orbData.mesh.position);
                });
                if (isTunneling) {
                    camera.position.y += BASE_TUNNELING_SPEED * currentSpeedMultiplier;
                    if (camera.position.y > verticalDistanceOfHelix / 2 + 50) { isTunneling = false; initialTunnelComplete = true; camera.position.y = 0; camera.position.z = 250; coreHelix.rotation.set(0, 0, 0); if (controlsTopElement) controlsTopElement.classList.remove('controls-hidden'); if (controlsBottomElement) controlsBottomElement.classList.remove('controls-hidden'); }
                    camera.lookAt(new THREE.Vector3(0, camera.position.y + 100, 0));
                } else {
                    if (!isMouseDown) { const currentPhase = animationPhases[currentPhaseIndex]; coreHelix.rotation.y += currentPhase.rotationSpeedY * currentSpeedMultiplier * (deltaTime / 16.6667); coreHelix.rotation.x += currentPhase.rotationSpeedX * currentSpeedMultiplier * (deltaTime / 16.6667); phaseTimer += deltaTime;
                        if (phaseTimer >= currentPhase.duration) { currentPhaseIndex = (currentPhaseIndex + 1) % animationPhases.length; phaseTimer = 0; }
                    }
                } renderer.render(scene, camera);
            }

            function addEventListenersDNASim() {
                // Canvas já obtido
                window.addEventListener('resize', onWindowResizeDNASim, false);
                // Listener para fullscreenchange (adicionado)
                document.addEventListener('fullscreenchange', onWindowResizeDNASim, false);

                dnaSimCanvas.addEventListener('mousedown', onMouseDown, false);
                dnaSimCanvas.addEventListener('mousemove', onMouseMove, false);
                window.addEventListener('mouseup', onMouseUp, false);
                dnaSimCanvas.addEventListener('wheel', onMouseWheel, { passive: false });
                tunnelButtonElement.addEventListener('click', startTunneling);
                phaseToggleButtonElement.addEventListener('click', toggleAnimationPhase);
                speedSliderElement.addEventListener('input', updateSpeedMultiplier);
                radiusSliderElement.addEventListener('input', updateHelixParameters);
                turnsSliderElement.addEventListener('input', updateHelixParameters);
                exitDNASimButtonElement.addEventListener('click', () => { console.log("Exit button clicked."); });
            }

            function onWindowResizeDNASim() {
                // Canvas já obtido
                if (dnaSimCanvas && renderer && camera) {
                    // Use parentElement dimensions for correct sizing, especially in fullscreen
                    const width = dnaSimCanvas.parentElement.clientWidth;
                    const height = dnaSimCanvas.parentElement.clientHeight;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                }
            }
            function onMouseDown(event) { if (isTunneling) return; isMouseDown = true; previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY; }
            function onMouseMove(event) {
                if (!isMouseDown || isTunneling) return; const deltaX = event.clientX - previousMousePosition.x; const deltaY = event.clientY - previousMousePosition.y; coreHelix.rotation.y += deltaX * 0.005; coreHelix.rotation.x += deltaY * 0.005; previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY;
            }
            function onMouseUp() { if (isTunneling) return; isMouseDown = false; }
            function onMouseWheel(event) { if (isTunneling) return; event.preventDefault(); camera.position.z -= event.deltaY * 0.1; }
            function startTunneling() {
                isTunneling = true;
                if (initialTunnelComplete) { if (controlsTopElement) controlsTopElement.classList.add('controls-hidden'); if (controlsBottomElement) controlsBottomElement.classList.add('controls-hidden'); }
                camera.position.y = -verticalDistanceOfHelix / 2 + 10; camera.position.z = 5; coreHelix.rotation.set(0, 0, 0); currentPhaseIndex = 0; phaseTimer = 0;
            }
            function toggleAnimationPhase() { if (isTunneling) return; currentPhaseIndex = (currentPhaseIndex + 1) % animationPhases.length; phaseTimer = 0; }
            function updateSpeedMultiplier(event) { const sliderValue = parseInt(event.target.value); currentSpeedMultiplier = MIN_SPEED_MULTIPLIER + (sliderValue / 100) * (MAX_SPEED_MULTIPLIER - MIN_SPEED_MULTIPLIER); }
            function updateHelixParameters() {
                const ultravioletViolet = "#4A006F"; const solarYellow = "#FFEF00";
                currentHelixRadius = parseInt(radiusSliderElement.value); currentHelixTurns = parseInt(turnsSliderElement.value);
                if (coreHelix) { scene.remove(coreHelix); }
                verticalDistanceOfHelix = (120 / 4) * currentHelixTurns * 1.0;
                coreHelix = createHelix(1.0, currentHelixRadius, currentHelixTurns, ultravioletViolet, solarYellow); scene.add(coreHelix);
                orbs.forEach((orbData, i) => { const newBaseY = (i / (NUM_ORBS - 1)) * verticalDistanceOfHelix - (verticalDistanceOfHelix / 2); orbData.baseY = newBaseY; orbData.mesh.position.y = newBaseY + Math.sin(performance.now() * ORB_OSCILLATION_SPEED_BASE + orbData.oscillationOffset) * ORB_OSCILLATION_RANGE; orbData.light.position.copy(orbData.mesh.position); });
            }

            // --- SCRIPT EXECUTION ---
            initDNASimulation();
            animateDNASim();
        });
    </script>
</body>
</html>

